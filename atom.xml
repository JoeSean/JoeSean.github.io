<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sean&#39;s blog</title>
  
  <subtitle>代码常变，初心不变</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-12T09:23:25.225Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Sean</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swoole的进程与热重载</title>
    <link href="http://yoursite.com/2018/10/07/swoole-study-6/"/>
    <id>http://yoursite.com/2018/10/07/swoole-study-6/</id>
    <published>2018-10-07T05:38:22.000Z</published>
    <updated>2019-04-12T09:23:25.225Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/szyhf/swoole_study/blob/master/Swoole%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%83%AD%E9%87%8D%E8%BD%BD.md" target="_blank" rel="noopener">转载原文</a></p><h4 id="重载之初"><a href="#重载之初" class="headerlink" title="重载之初"></a>重载之初</h4><p>在传统的LAMP环境中，我们调试应用有时候非常简单，修改，保存，重新访问（网页），就能看到刚刚修改的代码的效果，所以很多童鞋都习惯了随改随用，可是当业务来到Swoole Server的时候，却发现了一些不同。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 篇幅原因，省略其他代码，我们仅来看看OnReceive的时候</span><br><span class="line">$server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data)&#123;</span><br><span class="line">    echo &quot;Receive something\n&quot;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这段DEMO的逻辑非常简单，每当Server收到一个包的时候，输出一段文字。我们来模拟一个业务调整的场景，希望Server在收到包的时候，输出两段文字，现在我们简单修改一下代码如下并保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 篇幅原因，省略其他代码，我们仅来看看OnReceive的时候</span><br><span class="line">$server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data)&#123;</span><br><span class="line">    echo &quot;Receive something\n&quot;;</span><br><span class="line">    echo &quot;I can not receive anything\n&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后再使用telnet作为测试工具，向Server发出请求，然后就像很多童鞋学习过程中遇到的那样，输出仍然是“Receive something\n”，后加的“I can not receive anything\n”并不会出现。</p><blockquote><p>这个结果与我们习惯中即插即用的PHP表现并不相同。</p></blockquote><p>这是什么原因呢？首先，我们要从LAMP的工作特性说起，如果说Linux隔离的是硬件层和软件层（作为操作系统），那么Apache在这个框架下隔离的其实是TCP Server和Handle HTTP REQUEST的工作，也就是说，每当客户端发送一个HTTP Request给Apache的时候，Apache首先将其按HTTP协议的格式进行解析，再根据当前自己加载的配置文件，搜索可以处理这个HTTP请求的程序（在此可以看作是Zend引擎），并根据URL描述的路径找到相关的*.php文件，通过调用Zend解析并执行该文件中PHP的代码，并返回输出，Apache获得输出以后，重新组织成合适的HTTP Response，并返回个客户端（在这个场景下就是浏览器了）。</p><blockquote><p>部分内容可以参见拙作《当SWOLLE遇上Server》、《当SWOOLE遇上PROTOCOL》，草蛇灰线的铺垫感觉终于在新的一年冒泡了=。=</p></blockquote><p>这个过程中，我们参考一下上一章《SWOOLE的多进程模型》，我们能发现什么相似的地方吗？</p><p>木有错，从分工的角度上看，Apache就像Master进程一样，承担了维持连接并转发请求的工作，而具体的业务内容，是由Zend引擎和其执行并加载的PHP代码所决定的。</p><blockquote><p>正如我们所知的一样，Apache并不止可以处理PHP的服务，它本质上是一个Web Server的容器</p></blockquote><p>换个角度讲，之所以我们在使用LAMP的过程中，修改PHP代码以后可以马上看到效果，是因为每个新的请求都是重新调用Zend重新解析硬盘上的PHP代码文件而获得的。</p><p>显而易见，这种模式的优点就是开发简便，快速；这也是PHP为什么能在WEB开发中雄霸天下的重要原因之一。</p><blockquote><p>性能问题，往往是在开发效率和执行效率上取得一个平衡。</p></blockquote><p>然而，有利，就自然有弊，可以想象，当业务正式上线，代码趋于稳定，不需要经常修改的时候，每次收到业务请求的时候都要重新从硬盘中读取文件，再加载到内存，然后解析执行显然会造成大量的时间浪费。</p><blockquote><p>传统的PHP模型中，显然也不会忽略这个问题，有大量的工具都可用于或设计于解决这个问题，笔者这里就不罗嗦了。</p></blockquote><p>而SWOOLE Server作为PHP的进阶工具，它设计之初就是面向高性能以及更底层的业务开发而设计的，所以，它的默认设计下并不能支持即改即用。</p><blockquote><p>事实上，笔者很多时候喜欢在HTTP Server的本地环境调试业务代码，享受PHP的高效调试，等稳定了再提交到SWOOLE Server进行进一步的处理，一般来说，如果抽象的当，代码的公用并不需要修改任何东西。</p></blockquote><h4 id="重载进行时"><a href="#重载进行时" class="headerlink" title="重载进行时"></a>重载进行时</h4><p>咳咳，扯了五十多行的淡，让笔者回收一下不知道飞到哪里的思路，回到SWOOLE Server热重载的问题上。</p><p>在上一章中，我们已经介绍了，业务问题放在Worker进程中处理的基本原则，那么这里，我们也可以大胆推断一下为什么修改PHP文件后，代码并不能生效的问题。</p><p>因为，PHP代码中的内容已经被加载到了内存中，每次收到业务请求的时候，SWOOLE Server并不会重新从硬盘中读取新的PHP文件，而是直接根据已加载到内存中的代码执行业务逻辑。</p><p>所以，最简单的重载方法就粗线了：把当前Server相关进程干掉，然后重启服务。</p><p>如笔者在拙作《当SWOOLE遇上TCP》中介绍的，一个TCP连接就像打电话，而一个Web Server的业务特性决定了它往往需要同时维护多个通信连接。</p><p>而把Server干掉相当与什么情况呢？把所有的电话线瞬间剪断，不考虑你已经说了一半的话，例如，当“我不想再做你的‘不歪富源德’了，我要做你的‘哈斯笨的’”由于通话中断而变成“我不想再做你的‘不歪富源德’了”，本来只要9.9就能解决的问题，分分钟演化成在99集的八点档狗血电视剧。</p><blockquote><p>在《当SWOOLE遇上PROTOCOL》一文中，其实设计PROTOCOL也是为了避免类似的问题，但两者的手段不同，PROTOCOL是在业务逻辑中，而这里讨论的是运作机制上。</p></blockquote><p>那确实发生需要修复Server的时候，应该怎么办呢？在Swoole的多进程模型中，Master进程负责维护所有与客户端的连接，而Worker进程才是处理业务逻辑的地方，也就是说，我们重载业务的时候，并不需要把整个Server都干掉，我们只需要干掉Worker进程，然后重新启动就可以了。</p><blockquote><p>其实热重载，在笔者看来，可以看作一种小范围的重启</p></blockquote><p>但是，我们的Worker如果正在执行某个工作，忽然被打断，怎么办？这样虽然保住了电话线，但业务层的事务性就可能会出现问题了不是么？</p><p>当然，SWOOLE Server设计了更优雅的策略来处理这个问题，也就是本章的主体，热重载的一般用法。</p><h4 id="重载与进程通讯"><a href="#重载与进程通讯" class="headerlink" title="重载与进程通讯"></a>重载与进程通讯</h4><p>我们先假设有如下的Swoole进程正在工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 这个名称只是示意，并非真实的运行情况</span><br><span class="line">-php 12138 swoole_master</span><br><span class="line">    |-php 12139 swoole_manager</span><br><span class="line">        |-php 12140 swoole_worker_01</span><br><span class="line">        |-php 12141 swoole_worker_02</span><br></pre></td></tr></table></figure><p>正如我们上次聊的那样，Master进程收到了客户端的请求以后，解决了TCP级别的协议问题后，就把请求交给了manager进程处理，而manager进程则会进一步的把工作交给worker，最后的业务逻辑是在woeker中完成的。</p><p>那么此时我们需要告知Server，代码发生了变动，快干掉现有的Worker进程，重新读取硬盘的文件并拉起新的Worker进程应该怎么做呢？</p><p>从工作机制上，其实只需要Manager进程和Worker进程相互配合好即可。</p><p>对于Manager进程而言，它只需要做到一点，如果发现麾下的某个Worker进程不是正常退出的，那么Manager进程要负责重新拉起一个Worker进程，而重新拉起Worker进程的时候，由于内存里已经没有了旧的Worker进程，则需要重新从硬盘中读取代码。</p><blockquote><p>事实上，这个设计同时还保障了如果由于业务原因导致某个Worker进程意外挂掉了，还会有新的Worker进程被生产出来，用于保障服务。</p></blockquote><p>对于Worker进程而言，我们都知道，每当某个Worker手头的工作完成后，都要把自己已经空下来，可以接受新的工作的状态告诉Manager进程，以便于Manager进程分配新的工作给Worker进程，换个角度讲，Manager进程是知道某个Worker进程的工作状态的，为了防止事务行为被重载打断，只要调Worker进程空闲的时候重载，就可以了。</p><blockquote><p>这是个很经典的异步协同工作流程。</p></blockquote><p>而怎么实现这个过程呢？Swoole Server已经提供了接口，就是通过kill命令向Manager进程发送SIGUSR1（-10）的信号量，则Manager进程就会先Hold住当前接受到的请求（队列），把已经空闲的Worker进程干掉，并重新拉起新的Worker进程，并将新的请求交给新的Worker进程处理，直到所有的Worker进程都被重新拉起为止。</p><blockquote><p>这其实是柔性终止/重启机制，不立即把进程干掉，而是先禁止进程接收新的请求，然后允许进程把手头上正在处理的业务做完，再稳定退出进行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 如上文中我们知道了Manager进程的pid是12139</span><br><span class="line">sudo kill -10 12139</span><br><span class="line"></span><br><span class="line"># 等待worker完成已有的工作，再执行pstree看看</span><br><span class="line">-php 12138 swoole_master</span><br><span class="line">    |-php 12139 swoole_manager</span><br><span class="line">        |-php 12142 swoole_worker_01</span><br><span class="line">        |-php 12143 swoole_worker_02</span><br></pre></td></tr></table></figure><p>新的worker已经被拉起，新的代码也都被加载到了Worker的进程中，新的传说即将开启……</p><blockquote><p>再用telnet发送一个请求看看？</p></blockquote><h4 id="思考与展望"><a href="#思考与展望" class="headerlink" title="思考与展望"></a>思考与展望</h4><p>讲到这里，热重载的一般性问题已经基本到此结束了，其实笔者想介绍的核心特点还是代码的执行方式，所导致的执行结果的不同，并反应在调用逻辑上，PHP作为脚本语言，天性上就更容易被忽略其被加载到内存的过程，不像C等静态语言，需要明确的编译链接才能执行，因此容易误会，其实无论哪种策略也好，并没有最优与最劣，只有最合适。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/szyhf/swoole_study/blob/master/Swoole%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%83%AD%E9%87%8D%E8%BD%BD.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载原文&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;重载之初&quot;&gt;&lt;a href=&quot;#重载之初&quot; class=&quot;headerlink&quot; title=&quot;重载之初&quot;&gt;&lt;/a&gt;重载之初&lt;/h4&gt;&lt;p&gt;在传统的LAMP环境中，我们调试应用有时候非常简单，修改，保存，重新访问（网页），就能看到刚刚修改的代码的效果，所以很多童鞋都习惯了随改随用，可是当业务来到Swoole Server的时候，却发现了一些不同。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SWOOLE" scheme="http://yoursite.com/tags/SWOOLE/"/>
    
  </entry>
  
  <entry>
    <title>Swoole的进程模型</title>
    <link href="http://yoursite.com/2018/10/01/swoole-study-5/"/>
    <id>http://yoursite.com/2018/10/01/swoole-study-5/</id>
    <published>2018-10-01T11:32:12.000Z</published>
    <updated>2019-04-12T09:23:25.136Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/szyhf/swoole_study/blob/master/Swoole%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.md" target="_blank" rel="noopener">转载原文</a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前文再续，就书接上一回，随着与Server、TCP、Protocol的邂逅，Swoole终于迎来了自己的故事，今天，我们来聊聊Swoole的进程模型。<br><a id="more"></a></p><blockquote><p>前边几篇东西虽然标题是Swoole，其主要讲的是操作系统、计算机网络方面的知识，包括一点点笔者自己的私货，今天终于放假了，咱可以讨论一下公的了=。=</p></blockquote><h4 id="并发之始"><a href="#并发之始" class="headerlink" title="并发之始"></a>并发之始</h4><p>之前我们已经初步讨论的一个WebServer是怎样工作的，但之前的例子中，我们看到的服务都是一个客户端与一个服务端一问一答的场景，但事实上，绝大部分时候我们预期的服务并不是只向一个客户端提供服务，所以，作为一个成熟的Server，并发\并行问题是必须解决的。</p><blockquote><p>其实，“并发”和“并行”两个概念在计算机中是相关但不同的，有兴趣的童鞋可以自己搜索一下，笔者今天仅讨论并发咯。</p></blockquote><p>而软件开发中，最常见的并发问题解决方案，莫过于多线程/多进程两种模式了。</p><blockquote><p>微软的体系中，除了线程，还有“纤程”；而最近非常火爆的“协程”，则又是另一个解决方案了。</p></blockquote><p>在《计算机组成原理》中我们都学过，并发中最迫切需要解决的问题之一，就是数据的可靠性问题，而不同的并发模型，其并发数据可靠性的机制往往各有特点，因此，在使用Swoole Server\Client的过程中，其并发解决方案的模型是必须要了解的，否则使用上很容易出现不符合预期的结果。</p><blockquote><p>简单说，就是防止脏读脏写</p></blockquote><p>Swoole目前总共有三种运行模式，其中Base模式基本没有生产应用价值；协程模式暂时还处于预览阶段；因此，笔者在此想和大家讨论的，就是Swoole的多进程模式，也是官方目前最推荐用于生产环境的模式。</p><blockquote><p>事实上，Swoole曾经还有多线程模式，但由于Zend在多线程模式本身的缺陷，在1.6版本后，多线程模式已经被关闭。</p></blockquote><h4 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h4><p>首先，我们还是来简单回顾一下Swoole Server的构造函数，之前我们已经解决了Host、Port、Protocol的问题，这期我们来看最后一个参数的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$server = new \swoole_server(&quot;127.0.0.1&quot;,8088,SWOOLE_PROCESS,SWOOLE_SOCK_TCP);</span><br></pre></td></tr></table></figure><p>第三个参数mode中我们填入的PROCESS，即表示当前Server是运行于多进程模式的。</p><blockquote><p>其他mode的可选参数可以参考手册</p></blockquote><p>然后，我们简单实现一个没有任何内容的Server：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$server = new \swoole_server(&quot;127.0.0.1&quot;,8088,SWOOLE_PROCESS,SWOOLE_SOCK_TCP);</span><br><span class="line"></span><br><span class="line">$server-&gt;on(&apos;connect&apos;, function ($serv, $fd)&#123; &#125;);</span><br><span class="line"></span><br><span class="line">$server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data)&#123; &#125;);</span><br><span class="line"></span><br><span class="line">$server-&gt;on(&apos;close&apos;, function ($serv, $fd)&#123; &#125;);</span><br><span class="line"></span><br><span class="line">$server -&gt; start();</span><br></pre></td></tr></table></figure><p>在启动服务之后，我们继续在Shell中输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; php swoole_server_demo.php</span><br><span class="line">&gt; pstree -ap|grep swoole_server_demo</span><br><span class="line">  |-php,2829 swoole_server_demo.php</span><br><span class="line">  |   |-php,2831 swoole_server_demo.php</span><br><span class="line">  |   |   `-php,2836 swoole_server_demo.php</span><br></pre></td></tr></table></figure><blockquote><p>pstree命令可以查看进程的树模型</p></blockquote><p>从系统的输出中，我们可以很容看出server其实有3个进程，进程的pid分别是2829、2831、2836，其中2829是2831的父进程，而2831又是2836的父进程。</p><blockquote><p>所以，其实我们虽然看起来只是启动了一个Server，其实最后产生的是三个进程。</p></blockquote><p>这三个进程中，所有进程的根进程，也就是例子中的2829进程，就是所谓的Master进程；而2831进程，则是Manager进程；最后的2836进程，是Worker进程。</p><p>基于此，我们简单梳理一下，当执行的start方法之后，发生了什么：</p><ol><li>守护进程模式下，当前进程fork出Master进程，然后退出，Master进程触发OnMasterStart事件。</li><li>Master进程启动成功之后，fork出Manager进程，并触发OnManagerStart事件。</li><li>Manager进程启动成功时候，fork出Worker进程，并触发OnWorkerStart事件。</li></ol><blockquote><p>非守护进程模式下，则当前进程直接作为Master进程工作。</p></blockquote><p>所以，一个最基础的Swoole Server，至少需要有3个进程，分别是Master进程、Manager进程和Worker进程。</p><blockquote><p>不要看到进程多就觉得麻烦咯，其实全赖它们各司其职，才有Swoole重新定义PHP的壮举。</p></blockquote><p>事实上，一个多进程模式下的Swoole Server中，有且只有一个Master进程；有且只有一个Manager进程；却可以有n个Worker进程。</p><blockquote><p>那么这几个进程之间是怎么协同工作的呢？我们先暂时考虑只有一个Worker的情况。</p></blockquote><p>那么，我们又可以拉出之前写的最简单Server，来看看这个过程中，三种进程之间是怎么协作的。</p><ol><li>Client主动Connect的时候，Client实际上是与Master进程中的某个Reactor线程发生了连接。</li><li>当TCP的三次握手成功了以后，由这个Reactor线程将连接成功的消息告诉Manager进程，再由Manager进程转交给Worker进程。</li><li>在这个Worker进程中触发了OnConnect的方法。</li><li>当Client向Server发送了一个数据包的时候，首先收到数据包的是Reactor线程，同时Reactor线程会完成组包，再将组好的包交给Manager进程，由Manager进程转交给Worker。</li><li>此时Worker进程触发OnReceive事件。</li><li>如果在Worker进程中做了什么处理，然后再用Send方法将数据发回给客户端时，数据则会沿着这个路径逆流而上。</li></ol><blockquote><p>同样的故事，随着认识的加深，会发现不一样的精彩</p></blockquote><p>首先，Master进程是一个多线程进程，其中有一组非常重要的线程，叫做Reactor线程（组），每当一个客户端连接上服务器的时候，都会由Master进程从已有的Reactor线程中，根据一定规则挑选一个，专门负责向这个客户端提供维持链接、处理网络IO与收发数据等服务。</p><blockquote><p>以前我们提到的分包拆包等功能也是在这里完成的哦。</p></blockquote><p>而Manager进程，某种意义上可以看做一个代理层，它本身并不直接处理业务，其主要工作是将Master进程中收到的数据转交给Worker进程，或者将Worker进程中希望发给客户端的数据转交给Master进程进行发送。</p><p>另外，Manager进程还负责监控Worker进程，如果Worker进程因为某些意外挂了，Manager进程会重新拉起新的Worker进程，有点像Supervisor的工作</p><blockquote><p>而这个特性，也是最终实现热重载的核心机制。</p></blockquote><p>最后就是Worker进程了，顾名思义，Worker进程其实就是处理各种业务工作的进程，Manager将数据包转交给Worker进程，然后Worker进程进行具体的处理，并根据实际情况将结果反馈给客户端。</p><p>如果要打个比方的话，Master进程就像业务窗口的，Reactor就是前台接待员，用户很多的时候，后边的用户就需要排队等待服务；Reactor负责与客户直接沟通，对客户的请求进行初步的整理（传输层级别的整理——组包）；然后，Manager进程就是类似项目经理的角色，要负责将业务分配给合适的Worker（例如空闲的Worker）；而Worker进程就是工人，负责实现具体的业务。</p><blockquote><p>实际上，一对多投递这种模式总是在并发的程序设计非常常见：1个Master进程投递n个Reactor线程；1个Manager进程投递n个Worker进程。</p></blockquote><p>现在，我们来看看一个简单的多进程Swoole Server的几个基本配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$server-&gt;set([</span><br><span class="line">&quot;daemonize&quot;=&gt;true,</span><br><span class="line">&quot;reactor_num&quot;=&gt;2,</span><br><span class="line">&quot;worker_num&quot;=&gt;4,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$server -&gt; start();</span><br></pre></td></tr></table></figure><p>reactor_num：表示Master进程中，Reactor线程总共开多少个，注意，这个可不是越多越好，因为计算机的CPU是有限的，所以一般设置为与CPU核心数量相同，或者两倍即可。</p><p>worker_num：表示启动多少个Worker进程，同样，Worker进程数量不是越多越好，仍然设置为与CPU核心数量相同，或者两倍即可。</p><blockquote><p>读书万卷不若自己亲手写一行，试验一下这个配置下，Server启动后，pstree的结构。</p></blockquote><h4 id="进程模型与数据共享"><a href="#进程模型与数据共享" class="headerlink" title="进程模型与数据共享"></a>进程模型与数据共享</h4><p>在以前的讨论中，我们最常接触到的回调方法如下：</p><ol><li>OnConnect</li><li>OnReceive</li><li>OnClose</li></ol><p>如上一节所说，这三个回调其实都是在Worker进程中发生的，而了解了进程模型以后，我们可以认识一下更多的回调方法了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 以下回调发生在Master进程</span><br><span class="line">$server-&gt;on(&quot;start&quot;, function (\swoole_server $server)&#123;</span><br><span class="line">echo &quot;On master start.&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">$server-&gt;on(&apos;shutdown&apos;, function (\swoole_server $server)&#123;</span><br><span class="line">echo &quot;On master shutdown.&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 以下回调发生在Manager进程</span><br><span class="line">$server-&gt;on(&apos;ManagerStart&apos;, function (\swoole_server $server)&#123;</span><br><span class="line">echo &quot;On manager start.&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">$server-&gt;on(&apos;ManagerStop&apos;, function (\swoole_server $server)&#123;</span><br><span class="line">echo &quot;On manager stop.&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 以下回调也发生在Worker进程</span><br><span class="line">$server-&gt;on(&apos;WorkerStart&apos;, function (\swoole_server $server, $worker_id)&#123;</span><br><span class="line">echo &quot;Worker start&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">$server-&gt;on(&apos;WorkerStop&apos;, function(\swoole_server $server, $worker_id)&#123;</span><br><span class="line">echo &quot;Worker stop&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">$server-&gt;on(&apos;WorkerError&apos;, function(\swoole_server $server, $worker_id, $worker_pid, $exit_code)&#123;</span><br><span class="line">echo &quot;Worker error&quot;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>OK，现在我们更新一下我们的测试代码，以展示不同进程之间，数据共享的特点和关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">$server = new \swoole_server(&quot;127.0.0.1&quot;,8088,SWOOLE_PROCESS,SWOOLE_SOCK_TCP);</span><br><span class="line"></span><br><span class="line">$server-&gt;on(&apos;connect&apos;, function ($serv, $fd)&#123; &#125;);</span><br><span class="line"></span><br><span class="line">$server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data)&#123; &#125;);</span><br><span class="line"></span><br><span class="line">$server-&gt;on(&apos;close&apos;, function ($serv, $fd)&#123; &#125;);</span><br><span class="line"></span><br><span class="line">// 在交互进程中放入一个数据。</span><br><span class="line">$server-&gt;BaseProcess = &quot;I&apos;m base process.&quot;</span><br><span class="line"></span><br><span class="line">// 为了便于阅读，以下回调方法按照被起调的顺序组织</span><br><span class="line">// 1. 首先启动Master进程</span><br><span class="line">$server-&gt;on(&quot;start&quot;, function (\swoole_server $server)&#123;</span><br><span class="line">    echo &quot;On master start.&quot;.PHP_EOL;</span><br><span class="line">    // 先打印在交互进程写入的数据</span><br><span class="line">    echo &quot;server-&gt;BaseProcess = &quot;.$server-&gt;BaseProcess.PHP_EOL;</span><br><span class="line">    // 修改交互进程中写入的数据</span><br><span class="line">    $server-&gt;BaseProcess = &quot;I&apos;m changed by master.&quot;;</span><br><span class="line">// 在Master进程中写入一些数据，以传递给Manager进程。</span><br><span class="line">$server-&gt;MasterToManager = &quot;Hello manager, I&apos;m master.&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 2. Master进程拉起Manager进程</span><br><span class="line">$server-&gt;on(&apos;ManagerStart&apos;, function (\swoole_server $server)&#123;</span><br><span class="line">echo &quot;On manager start.&quot;.PHP_EOL;</span><br><span class="line">// 打印，然后修改交互进程中写入的数据</span><br><span class="line">echo &quot;server-&gt;BaseProcess = &quot;.$server-&gt;BaseProcess.PHP_EOL;</span><br><span class="line">$server-&gt;BaseProcess = &quot;I&apos;m changed by manager.&quot;;</span><br><span class="line">// 打印，然后修改在Master进程中写入的数据</span><br><span class="line">echo &quot;server-&gt;MasterToManager = &quot;.$server-&gt;MasterToManager.PHP_EOL;</span><br><span class="line">$server-&gt;MasterToManager = &quot;This value has changed in manager.&quot;;</span><br><span class="line"></span><br><span class="line">// 写入传递给Worker进程的数据</span><br><span class="line">$server-&gt;ManagerToWorker = &quot;Hello worker, I&apos;m manager.&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 3. Manager进程拉起Worker进程</span><br><span class="line">$server-&gt;on(&apos;WorkerStart&apos;, function (\swoole_server $server, $worker_id)&#123;</span><br><span class="line">echo &quot;Worker start&quot;.PHP_EOL;</span><br><span class="line">// 打印在交互进程写入，然后在Master进程，又在Manager进程被修改的数据</span><br><span class="line">echo &quot;server-&gt;BaseProcess = &quot;.$server-&gt;BaseProcess.PHP_EOL;</span><br><span class="line"></span><br><span class="line">// 打印，并修改Master写入给Manager的数据</span><br><span class="line">echo &quot;server-&gt;MasterToManager = &quot;.$server-&gt;MasterToManager.PHP_EOL;</span><br><span class="line">$server-&gt;MasterToManager = &quot;This value has changed in worker.&quot;;</span><br><span class="line"></span><br><span class="line">// 打印，并修改Manager传递给Worker进程的数据</span><br><span class="line">echo &quot;server-&gt;ManagerToWorker = &quot;.$server-&gt;ManagerToWorker.PHP_EOL;</span><br><span class="line">$server-&gt;ManagerToWorker = &quot;This value is changed in worker.&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 4. 正常结束Server的时候，首先结束Worker进程</span><br><span class="line">$server-&gt;on(&apos;WorkerStop&apos;, function(\swoole_server $server, $worker_id)&#123;</span><br><span class="line">echo &quot;Worker stop&quot;.PHP_EOL;</span><br><span class="line">// 分别打印之前的数据</span><br><span class="line">echo &quot;server-&gt;ManagerToWorker = &quot;.$server-&gt;ManagerToWorker.PHP_EOL;</span><br><span class="line">echo &quot;server-&gt;MasterToManager = &quot;.$server-&gt;MasterToManager.PHP_EOL;</span><br><span class="line">echo &quot;server-&gt;BaseProcess = &quot;.$server-&gt;BaseProcess.PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 5. 紧接着结束Manager进程</span><br><span class="line">$server-&gt;on(&apos;ManagerStop&apos;, function (\swoole_server $server)&#123;</span><br><span class="line">    echo &quot;Manager stop.&quot;.PHP_EOL;</span><br><span class="line">// 分别打印之前的数据</span><br><span class="line">echo &quot;server-&gt;ManagerToWorker = &quot;.$server-&gt;ManagerToWorker.PHP_EOL;</span><br><span class="line">echo &quot;server-&gt;MasterToManager = &quot;.$server-&gt;MasterToManager.PHP_EOL;</span><br><span class="line">echo &quot;server-&gt;BaseProcess = &quot;.$server-&gt;BaseProcess.PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 6. 最后回收Master进程</span><br><span class="line">$server-&gt;on(&apos;shutdown&apos;, function (\swoole_server $server)&#123;</span><br><span class="line">echo &quot;Master shutdown.&quot;.PHP_EOL;</span><br><span class="line">// 分别打印之前的数据</span><br><span class="line">echo &quot;server-&gt;ManagerToWorker = &quot;.$server-&gt;ManagerToWorker.PHP_EOL;</span><br><span class="line">echo &quot;server-&gt;MasterToManager = &quot;.$server-&gt;MasterToManager.PHP_EOL;</span><br><span class="line">echo &quot;server-&gt;BaseProcess = &quot;.$server-&gt;BaseProcess.PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$server -&gt; start();</span><br></pre></td></tr></table></figure><p>这段程序测试的时候，我们需要开两个会话，第一个会话用于执行并打印输出；第二个会话用于使用kill命令通知Server执行一些工作，然后我们看看输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在会话一中</span><br><span class="line">&gt; php swoole_server_demo.php</span><br><span class="line">On master start.</span><br><span class="line">server-&gt;BaseProcess = I&apos;m base process.</span><br><span class="line">On manager start.</span><br><span class="line">server-&gt;BaseProcess = I&apos;m base process.</span><br><span class="line">server-&gt;MasterToManager = </span><br><span class="line">Worker start</span><br><span class="line">server-&gt;BaseProcess = I&apos;m base process.</span><br><span class="line">server-&gt;MasterToManager = </span><br><span class="line">server-&gt;ManagerToWorker =</span><br></pre></td></tr></table></figure><p>从Manager start和Worker start中的输出，我们发现BaseProcess、MasterToManager、ManagerToWorker并没有分别在Master、Manager中被修改，并在子进程中打印出被修改后的结果，这是为什么呢？别急，我们继续做个实验。</p><p>打开会话二，先执行pstree -ap|grep php找到刚刚启动的Server的Master进程的PID，然后向该进程发送-10信号，然后再次实行pstree命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; pstree -ap|grep php</span><br><span class="line">  |   |       `-php,5512 swoole_server_demo.php</span><br><span class="line">  |   |           |-php,5513 swoole_server_demo.php</span><br><span class="line">  |   |           |   `-php,5515 swoole_server_demo.php</span><br><span class="line">&gt;  kill -10 5512</span><br><span class="line">&gt; pstree -ap|grep php</span><br><span class="line">  |   |       `-php,5512 swoole_server_demo.php</span><br><span class="line">  |   |           |-php,5513 swoole_server_demo.php</span><br><span class="line">  |   |           |   `-php,5522 swoole_server_demo.php</span><br></pre></td></tr></table></figure><p>-10信号的作用是，要求Swoole重启Worker服务，我们会发现原来的Worker[5515]被干掉了，而产生了一个新的Worker[5522]，此时如果我们切换回会话一，会发现增加了以下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[2016-10-03 02:00:26 $5513.0]NOTICEServer is reloading now.</span><br><span class="line">Worker stop</span><br><span class="line">server-&gt;ManagerToWorker = This value is changed in worker.</span><br><span class="line">server-&gt;MasterToManager = This value has changed in worker.</span><br><span class="line">server-&gt;BaseProcess = I&apos;m base process.</span><br><span class="line">Worker start</span><br><span class="line">server-&gt;BaseProcess = I&apos;m changed by manager.</span><br><span class="line">server-&gt;MasterToManager = This value has changed in manager.</span><br><span class="line">server-&gt;ManagerToWorker = Hello worker, I&apos;m manager.</span><br></pre></td></tr></table></figure><p>首先是Swoole自己打印的日志信息，Server正在被reloading，然后Worker[5515]被终止，执行了WorkerStop的方法，此时WorkerStop输出的值我们可以看出，在WorkerStart中的赋值都是生效了的；然后，新的Worker[5522]被启动了，重新触发WorkerStart方法，这时我们发现，BaseProcess、MasterToManager和ManagerToWorker都分别被打印了出来？这是什么原因呢？</p><p>原因在方法被执行的顺序上，我们前文中的进程起调顺序并没有问题，但有些地方我们要做一点小小的细化：</p><ol><li>Master进程被启动。</li><li>Manager进程Master进程fork出来。</li><li>Worker进程被Manager进程fork出来。</li><li>MasterStart被回调。</li><li>ManangerStart被回调。</li><li>WorkerStart被回调。</li></ol><p>也就是说，三种进程的OnStart方法被回调的时候都有一定的延迟，底层事实上已经完工了fork的行为，才回调的，因此，默认启动的时候，我们在OnMasterStart、OnManagerStart中写入的数据并不能按预期被fork到Manager进程或者Worker进程。</p><p>然后，我们执行了kill -10重新拉起Worker进程的时候，此时Worker进程仍然是由Mananger进程fork出来的，但此时ManangerStart已经被执行过了，所以我们会发现在OnWorkerStart的时候，输出变成了ManagerStart中修改过的内容。</p><blockquote><p>OK，现在我们回到Shell会话二，向Master进程发送kill -15命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; kill -15 5512</span><br></pre></td></tr></table></figure><p>然后回到会话一，我们发现输出增加了如下的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[2016-10-03 02:17:35 #5512.0]NOTICEServer is shutdown now.</span><br><span class="line">Worker stop</span><br><span class="line">server-&gt;ManagerToWorker = This value is changed in worker.</span><br><span class="line">server-&gt;MasterToManager = This value has changed in worker.</span><br><span class="line">server-&gt;BaseProcess = I&apos;m changed by manager.</span><br><span class="line">Manager stop.</span><br><span class="line">server-&gt;ManagerToWorker = Hello worker, I&apos;m manager.</span><br><span class="line">server-&gt;MasterToManager = This value has changed in manager.</span><br><span class="line">server-&gt;BaseProcess = I&apos;m changed by manager.</span><br><span class="line">Master shutdown.</span><br><span class="line">server-&gt;ManagerToWorker = </span><br><span class="line">server-&gt;MasterToManager = Hello manager, I&apos;m master.</span><br><span class="line">server-&gt;BaseProcess = I&apos;m changed by master.</span><br></pre></td></tr></table></figure><p>kill -15命令是通知Swoole正常终止服务，首先停止Worker进程，触发OnWorkerStop回调，此时我们输出的内容懂事我们在WorkerStart中修改过的版本。</p><p>然后停止Manager进程，这时候要留意，我们在Worker中做的所有操作并没有反应在Manager进程上，OnManagerStop的输出仍然是在OnManagerStart中赋值的内容。</p><p>最后停止Master进程，也会有相同的事情发生。</p><p>通过以上实验，展示了多进程Server的两个重要特性：</p><ol><li>父进程fork出子进程的时候，子进程会拷贝一份父进程的所有数据。</li><li>各个进程之间的数据一般情况下是不共享内存的。</li></ol><blockquote><p>所以，学习Swoole的进一步需求就是，要弄清楚各个回调方法分别是在哪个进程中发生的，且发生的顺序是什么。</p></blockquote><p>这两个特性会引起什么问题呢？如果没有弄清楚当前的代码是在哪个进程执行的，很有可能就会引起数据的错误，而多个进程之间进行协作的话，不能像以往的PHP开发一样，通过共享变量实现。</p><blockquote><p>以上例子中，为了便于输出，没有启用守护进程模式，所以交互进程与Master进程是同一个进程，有兴趣的童鞋欢迎在守护进程下实验。</p></blockquote><p>所以，这又引出了下一个问题，多进程模型中，内存不能共享，那进程之间应该怎么通讯呢？限于篇幅，今天我们先讨论到这里，下一期我们再来探讨这个问题。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>今天，咱们讨论SWOOLE的多进程模型中，最简单也最基础的三进程的场景，并通过实例演示了Swoole Server的进程启动顺序，细化了Server与Client通信时，各个进程之间是分工协作的基本流程。最后给出了一个实验，并通过实验引入了各个进程起调时机，及由此产生的数据共享问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/szyhf/swoole_study/blob/master/Swoole%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载原文&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;前文再续，就书接上一回，随着与Server、TCP、Protocol的邂逅，Swoole终于迎来了自己的故事，今天，我们来聊聊Swoole的进程模型。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SWOOLE" scheme="http://yoursite.com/tags/SWOOLE/"/>
    
  </entry>
  
  <entry>
    <title>当SWOOLE遇上PROTOCOL</title>
    <link href="http://yoursite.com/2018/09/20/swoole-study-4/"/>
    <id>http://yoursite.com/2018/09/20/swoole-study-4/</id>
    <published>2018-09-20T09:22:12.000Z</published>
    <updated>2019-04-12T09:23:24.484Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/szyhf/swoole_study/blob/master/%E5%BD%93SWOOLE%E9%81%87%E4%B8%8APROTOCOL.md" target="_blank" rel="noopener">转载原文</a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>上回我们简单介绍了一下TCP Server的工作方式以及如何用Swoole实现一个简单的TCP Server，这次我们来聊聊信息流动中，非常重要基石之一——协议（PROTOCOL）。<br><a id="more"></a></p><h4 id="协议，通信的基石"><a href="#协议，通信的基石" class="headerlink" title="协议，通信的基石"></a>协议，通信的基石</h4><p>通信的双方约定一种理解的规则，以便对理解对方想表达的信息，这种解析信息的规则，就是今天的主题，协议。</p><blockquote><p>在语文上，我们用的是标点符号；数学上，我们有各种的加减乘除……</p></blockquote><h4 id="从HTTP到TCP，从应用层回到传输层"><a href="#从HTTP到TCP，从应用层回到传输层" class="headerlink" title="从HTTP到TCP，从应用层回到传输层"></a>从HTTP到TCP，从应用层回到传输层</h4><p>相信TCP协议（Transmission Control Protocol）应该是想学习SWOOLE的童鞋最容易遇到的拦路虎之一，因为一般我们使用PHP做网站开发的时候，并不需要处理涉及TCP协议的东西，只要了解一部分HTTP协议（HyperText Transfer Protocol）就可以做很多事情。</p><blockquote><p>甚至只是知道Get和Post就可以了，更细致的工作，巨人们已经帮我们完成了。</p></blockquote><p>在故事继续之前，请允许我先简单引入一下传说中的4层协议，TCP就是传输层的协议，而HTTP是应用层，这两个协议有什么关系呢？我们做个有趣的实验看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$server = new \swoole_server(&quot;127.0.0.1&quot;,8088,SWOOLE_PROCESS,SWOOLE_SOCK_TCP);</span><br><span class="line"></span><br><span class="line">$server-&gt;on(&apos;connect&apos;, function ($serv, $fd)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data)</span><br><span class="line">&#123;</span><br><span class="line">    // 这次，我们只需要简单的把收到的数据打印出来即可</span><br><span class="line">    // 但是，我们会在一头一尾各打印一行邪恶的分隔线</span><br><span class="line">    // 以便清楚的划分收到的数据内容</span><br><span class="line">    </span><br><span class="line">    echo &quot;====================邪恶的开头分隔线====================&quot;.PHP_EOL;</span><br><span class="line">    echo $data;//打印收到的数据正文</span><br><span class="line">    echo &quot;====================邪恶的结尾分隔线====================&quot;.PHP_EOL;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$server-&gt;on(&apos;close&apos;, function ($serv, $fd)</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;client: close.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$server -&gt; start();</span><br></pre></td></tr></table></figure><blockquote><p>远程主机\IP\端口的问题，本文就掠过啦，有需要看本系列的前作。</p></blockquote><p>好，我们之前是通过telnet，实现与SWOOLE的TCP Server之间的简单通信的，这次我们玩点不一样的，首先仍然是启动SWOOLE Server，然后，打开浏览器，没错，在地址栏中输入：“<a href="http://127.0.0.1:8088”" target="_blank" rel="noopener">http://127.0.0.1:8088”</a> ————</p><blockquote><p>喂，我运行的是TCP Server，开浏览器干什么啦？</p></blockquote><p>显然，浏览器什么都没有输出，又或者爆出一个错误，但这个时候返回我们的终端看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; php swoole_server_demo.php</span><br><span class="line">====================邪恶的开头分隔线====================</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8088</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/250.36 (KHTML, like Gecko) Chrome/52.0.2743.250 Safari/250.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line"></span><br><span class="line">====================邪恶的结尾分隔线====================</span><br></pre></td></tr></table></figure><p>没错，虽然我们运行的是TCP Server，虽然我们是使用浏览器，而不是telnet访问的，我们的Server仍然打印出了显然非常有规律的信息，相信很多童鞋已经发现了，我们使用Chrome开发网页时，经常使用的调试工具箱里，就会在Network工具中的Header中看到类似的东西。</p><blockquote><p>这就是根据HTTP协议编写的一段信息。</p></blockquote><p>而编写者是谁呢？没错，就是我们一直默默无闻而几乎是互联网改变世界的基石之一，浏览器，每当我们通过浏览器访问不同的网站时，浏览器都会默默生成类似的文本作为WebRequest的正文，提交给对应的服务端。</p><blockquote><p>有兴趣的童鞋，可以试试使用附带Get请求、Post请求等方式访问，看看Server端收到的文本所有什么不同</p></blockquote><p>木有错，这就是超文本传输协议的本体，也是为什么叫超文本的原因，它是通过特定格式的字符串完成请求的描述的，在《当SWOOLE遇上SERVER》一文中，我曾经提到Apache收到客户端请求以后，经过一定的解析，再由Zend调用PHP脚本执行业务工作并完成输出；这里提到的请求就是这个。</p><blockquote><p>当然，浏览器上经常遇到协议还有HTTPS，这里先按下不表。</p></blockquote><p>完整的HTTP协议非常复杂，笔者这里就不详细叙述了，但HTTP协议有一个基本规则，各个字段之间，是通过“\r\n”进行分割的，简单说，当我们收到一个“完整的”HTTP请求的时候，可以用explode方法快速的划分区段，然后再根据区段进行解析，就能知道用户请求的是什么了。</p><blockquote><p>看格式其实或多或少都能猜到写了什么</p></blockquote><p>知道用户请求的是什么，我们就可以选择性的输出用户想要的东西，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data)</span><br><span class="line">&#123;</span><br><span class="line">    $reqAry = explode(&quot;\r\n&quot;,$data);</span><br><span class="line">    </span><br><span class="line">    if (stripos($reqAry[0],&quot;Hello.php&quot;) !== FALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;用户想调用Hello.php&quot;.PHP_EOL;</span><br><span class="line">        $serv-&gt;send($fd,&quot;你调用了Hello.php方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (stripos($reqAry[0],&quot;World.php&quot;) !== FALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;用户想调用World.php&quot;.PHP_EOL;</span><br><span class="line">        $serv-&gt;send($fd,&quot;你调用了World.php方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;用户想请求了一个不支持的方法&quot;.PHP_EOL;</span><br><span class="line">        $serv-&gt;send($fd,&quot;404，你调用的方法我们不支持。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改一下receive的回调，对收到的数据使用“\r\n”进行分割，然后对第0个元素进行简单的判断处理，然后，在浏览器中分别访问：<a href="http://127.0.0.1:8088/Hello.php、http://127.0.0.1:8088/World.php、http://127.0.0.1:8088/Index.php，看看Shell中的输出：" target="_blank" rel="noopener">http://127.0.0.1:8088/Hello.php、http://127.0.0.1:8088/World.php、http://127.0.0.1:8088/Index.php，看看Shell中的输出：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; php swoole_server_demo.php</span><br><span class="line">用户想调用Hello.php</span><br><span class="line">用户想调用World.php</span><br><span class="line">用户想请求了一个不支持的方法</span><br></pre></td></tr></table></figure><p>然后我们会发现浏览器分别打印了我们在分支语句中send回来的内容，就像平时调用了echo一样。</p><blockquote><p>严格来说，这样写，不一定能输出出来，因为HTTP协议对返回值的格式也有约定。</p></blockquote><p>如果我们对这个方法做的更完善一些，例如根据请求名，反射出Controller实例，并执行Controller的某个Method，整个过程几乎就跟我们常见的MVC框架一样了。</p><blockquote><p>事实上，在笔者看来，C中执行的业务逻辑，可以看作是”业务层”协议了</p></blockquote><p>无论是根据“\r\n”分段也好，根据“ ”拆分每段内部的字段也好，这些规则，都是协议本身的一部分。</p><blockquote><p>一般网络小说中，掌握了规则的强者总是开始努力打破规则，乃至定制自己的规则（所谓我的领域做主）</p></blockquote><p>HTTP的规则简单介绍的这里，我们回到一开始的问题，为什么我运行了一个TCP Server，却能实现HTTP的内容？</p><blockquote><p>相信盆友强忍着读到这里估计都会觉得笔者太罗嗦了，HTTP协议在传输层就是TCP协议实现的嘛</p></blockquote><p>想象一下你和你的基友正在打电话，你们说的是汉语、英语、德语、法语或者基语，是不是都不会影响两个电话之间的通信，电话工作是只要保证把声音传达到位，至于里边的内容，电话是不关心的。</p><blockquote><p>所谓不在其位，不谋其政</p></blockquote><p>而分层协议的工作原理也是一样，TCP作为传输层协议，它仅实现了传输层的某些特性，例如长连接，例如一个高可靠性的传输到位确认机制，但它对它传输的内容，具体怎么被识别或者处理，是不关心的。</p><blockquote><p>TCP也有自己的交互流程和解析机制，但要比HTTP复杂，这里就不讨论了。</p></blockquote><p>而HTTP协议是应用层协议，顾名思义，它关注的是应用，也就是收到传输层TCP收到的消息以后，根据具体的应用进行处理。</p><blockquote><p>除了HTTP以外，常见的诸如HTTPS、FTP、WebSocket等，也都是应用层协议，而它们的传输层都是TCP实现的。</p></blockquote><p>应用层协议百花齐放，传输层的协议却要凋零的多，最常见的，无非是TCP和UDP。</p><blockquote><p>就像有声语言可能有千百种，一个电话一个短信就够了。</p></blockquote><p>所以，在架设自己的TCP Server的时候，要解决的第一个问题，就是，我的应用层协议是什么？</p><h4 id="我心即天心"><a href="#我心即天心" class="headerlink" title="我心即天心"></a>我心即天心</h4><p>首先，要解决应用层协议的问题，先要选择一个传输层协议，基于这个协议的特点，我们再去设计应用层协议。</p><blockquote><p>就像选择开发语言和开发环境一样，虽然说语言只是工具，但工具也有适用场景，不是说绝对不行，只是事倍功半的事儿，必要时还是可以避免的。</p></blockquote><p>就像前文所言，协议的设计完全是由掌握了规则之力的人决定的（例如CTO），笔者这边就不多讨论怎么设计协议才是对的，仅介绍设计基于TCP协议时要注意的问题。</p><h4 id="无尽的数据流"><a href="#无尽的数据流" class="headerlink" title="无尽的数据流"></a>无尽的数据流</h4><p>TCP协议最大的一个特点，就是其传输的数据流是连续的，就像打电话一样，打电话的时候，我们以语气的停顿、语音、语调等作为理解对方意图的辅助元素，那TCP协议传输的数据流，OnReceive的时候也分分钟会遇到类似这样的问题：</p><blockquote><p>假设我们在tellnet中执行了以下的伪代码，向Server发送了7条数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; TCP协议最大的一个特点</span><br><span class="line">&gt; 就是其传输的数据流是连续的</span><br><span class="line">&gt; 就像打电话一样</span><br><span class="line">&gt; 打电话的时候</span><br><span class="line">&gt; 我们以语气的停顿</span><br><span class="line">&gt; 语音</span><br><span class="line">&gt; 语调等作为理解对方意图的辅助元素</span><br></pre></td></tr></table></figure><p>此时，虽然Server仍然有90%的可能（主要是网络通畅和输入的速度），OnReceive方法会被回调7次，而且每次收到的数据都与发送时一模一样，仍然不能排除会有以下的可能出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCP协议最大的一个特点就是其传输的数据流是连</span><br><span class="line">续的</span><br><span class="line">就像打</span><br><span class="line">电话一样打电话的时候我</span><br><span class="line">们以语气的停</span><br><span class="line">顿语音语调等作为理解对方意图的辅助元素</span><br></pre></td></tr></table></figure><p>首先，并不一定会回调7次，可能会回调1次就收到了所有数据，也可能要回调70次才能完整的收到所有数据，但是，无论回调多少次，收到的顺序是与发送顺序保持一致的，也就是不会出现以下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">续的</span><br><span class="line">就像打</span><br><span class="line">TCP协议最大的一个特点就是其传输的数据流是连</span><br><span class="line">们以语气的停</span><br><span class="line">顿语音语调等作为理解对方意图的辅助元素</span><br><span class="line">电话一样打电话的时候我</span><br></pre></td></tr></table></figure><p>所以，很多时候，我们都会称呼TCP的数据叫数据流，从传输层来看，TCP的数据包之间没有边界，怎么从TCP的数据流中正确的截取每个数据包，是设计TCP协议的第一步。</p><blockquote><p>这就是传说中的分包和合包</p></blockquote><p>最常见的数据包处理方式有两种，分别是结束符和固定包头两种，Swoole也非常贴心的替我们提供了这两种方案的常规处理，这样我们在使用的时候就不需要自己写分包合包的代码了。</p><h4 id="结束符（EOF）"><a href="#结束符（EOF）" class="headerlink" title="结束符（EOF）"></a>结束符（EOF）</h4><p>结束符处理方式很简单，双方约定各个数据包的结尾有稳定的结束符，且在数据包的正文中不要出现该结束符，那么数据的接收方，只要逐个字节地检查收到的数据，一旦发现结束符，就把上一个结束符（也可能是开头），到当前结束符之间的数据拆出来，作为一个数据包，进行进一步的处理</p><blockquote><p>常见的应用层协议中，MEMCACHE\FTP\STMP都是采用这种思路，它们使用的结束符是“\r\n”</p></blockquote><p>而在Swoole中，可以在配置中这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$server = new \swoole_server(&quot;127.0.0.1&quot;,8088,SWOOLE_PROCESS,SWOOLE_SOCK_TCP);</span><br><span class="line">$server-&gt;set(</span><br><span class="line">    [</span><br><span class="line">        &apos;open_eof_split&apos; =&gt; true,</span><br><span class="line">        &apos;package_eof&apos; =&gt; &quot;\r\n&quot;</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line">// 回调方法略</span><br><span class="line"></span><br><span class="line">$server-start();</span><br></pre></td></tr></table></figure><p>此时，假如发来的数据是根据”\r\n”作为结束符分包的数据流，每次OnReceive的时候，就一定是Swoole已经帮我们分好的数据包，我们直接做进一步的应用协议处理就好了。</p><h4 id="固定包头-包体"><a href="#固定包头-包体" class="headerlink" title="固定包头+包体"></a>固定包头+包体</h4><p>这种方案也是非常非常常见的解决方案，核心设计思路是，每个数据包由两部分组成，分别是固定长度的包头，和不确定长度的包体。包头中描述了包体的长度，接收数据的时候，先按包头的固定长度读取一定的数据，然后解析包头中的内容，获得这个数据包包体的长度，然后继续接收数据，直到收到了跟包头中描述的包体长度一样的数据，进而截断出完整的数据包。</p><blockquote><p>可以说，基本上除了EOF的方式以外，都是这种处理方式</p></blockquote><p>例如说，我们的数据包可以这么写：</p><blockquote><p>这个数据包由十九个字组成今天天气好好啊这个数据包由二十个字组成昨天晚上又加班了</p></blockquote><p>每个数据包的前12个字就是包头，读了包头，我们就知道了整个数据包的长度，减去包头12个字，就知道这个数据包剩下还要读取长了。</p><blockquote><p>当然，作为计算机，使用二进制的方式直接描述数据包才是更常见解决方案。</p></blockquote><p>例如说，我们约定包头的长度是4个byte，这4个byte按照大端序就组成了一个int，而这个int数据描述的就是整个数据包的长度（包括包头本身的4个byte的长度），那么此时，Swoole中的配置应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$server-&gt;set(</span><br><span class="line">    [</span><br><span class="line">        &apos;open_length_check&apos; =&gt; true,</span><br><span class="line">        &apos;package_length_type&apos; =&gt; &apos;N&apos;, //N表示32bit的大端序</span><br><span class="line">        &apos;package_length_offset&apos; =&gt; 0,//从第几个字节开始是长度，比如包头长度为4个byte，第0个byte开始就是长度值，那这里就填入0</span><br><span class="line">        &apos;package_body_offset&apos; =&gt; 2,//从第几个字节开始计算长度，比如包头为长度为4个byte，第0个字节为长度值，包体长度为1000。如果长度包含包头，这里填入0，如果不包含包头，这里填入4</span><br><span class="line">        &apos;package_max_length&apos; =&gt; 1024//最大允许的包长度。因为在一个请求包完整接收前，需要将所有数据保存在内存中，所以需要做保护。避免内存占用过大。</span><br><span class="line">    ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>关于TCP的通讯协议问题，SWOOLE手册中也有相关的说明<a href="https://wiki.swoole.com/wiki/page/484.html" target="_blank" rel="noopener">网络通信协议设计</a>。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>今天，笔者简单介绍了应用层协议和传输层协议的关系，并基于TCP协议，给出了基于TCP的应用层协议时，应当注意的问题，也给出了Swoole中相关的一些解决方案，希望能给刚接触网络通信的PHPer们带来一点启发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/szyhf/swoole_study/blob/master/%E5%BD%93SWOOLE%E9%81%87%E4%B8%8APROTOCOL.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载原文&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;上回我们简单介绍了一下TCP Server的工作方式以及如何用Swoole实现一个简单的TCP Server，这次我们来聊聊信息流动中，非常重要基石之一——协议（PROTOCOL）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SWOOLE" scheme="http://yoursite.com/tags/SWOOLE/"/>
    
  </entry>
  
  <entry>
    <title>当SWOOLE遇上TCP</title>
    <link href="http://yoursite.com/2018/09/19/swoole-study-3/"/>
    <id>http://yoursite.com/2018/09/19/swoole-study-3/</id>
    <published>2018-09-19T05:19:12.000Z</published>
    <updated>2019-04-12T09:23:24.403Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/szyhf/swoole_study/blob/master/%E5%BD%93SWOOLE%E9%81%87%E4%B8%8ATCP.md" target="_blank" rel="noopener">转载原文</a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前文再续，就书接上一回（拍一下惊堂木，然后喝口茶install一下B），话说笔者当初最早接触Swoole的时候，正迫切的期望能找到一个使用PHP作为主要开发语言的TCP Server的解决方案，因为公司业务中积累了大量的PHP代码，而新增的业务又迫切需要实现与客户端的主动通信，最终在盆友的推荐下，找到了Swoole。<br><a id="more"></a></p><h4 id="轮询与长连接"><a href="#轮询与长连接" class="headerlink" title="轮询与长连接"></a>轮询与长连接</h4><p>一般情况下，我们接触PHP都是作为一个Web网站的开发语言而接触的，例如一个最简单的HelloWorld.php，往往是这么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;Hello PHP&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>LAMP的配置这里就不多说了</p></blockquote><p>不自觉的，蓦然间会让我们产生一种错觉，PHP只能用来处理这种场景的工作，其他事情并不合适。</p><blockquote><p>亦或者说，很多盆友并没有意识到，PHP其实还隐藏了洪荒之力</p></blockquote><p>当时，笔者需要开发一个实时的消息服务APP，消息的实时性要求较高，也就是说，服务端需要可以主动向客户端推送消息，而这个时候，如果再采用传统的http api的方式，势必陷入轮询的困局。</p><blockquote><p>客户端每隔1s向服务器请求，检查是否有新的数据，这种场景可能会产生大量无用的请求，也会极大的增加服务端的负荷。</p></blockquote><p>传统的Web服务，采用http/https作为应用层协议，并且通过“请求-&gt;响应”的机制实现客户端和服务端的通讯，也就是说，服务端总是“被动”的提供服务，服务端“难以”主动的将消息告知客户端。</p><blockquote><p>这其实也是是websocket的产生背景。</p></blockquote><p>这个时候，我们可以考虑实现自己的TCP Server，以解决这个问题。</p><blockquote><p>显然，这里讨论的问题并不局限于开发语言，.Net、Java、Go、NodeJS等都有对应的解决方案。</p></blockquote><p>通过TCP协议构建的Server，是可以实现服务端和客户端保持一个持久的链接，链接一旦建立，就像电话打通了一样，通话的双方都可以主动向对方发送消息。</p><blockquote><p>其实http/https协议的传输层也是tcp协议，但为啥http/https协议变成了一次性的服务呢？有缘的话，下回分解。</p></blockquote><p>因此，双方的链接会呈现出“持久在线”的状态，也就是长连接这一说法的由来。</p><blockquote><p>有兴趣的盆友可以自行查找TCP是怎么实现“在线”这个状态的，还记得笔者上学时，计算机网络的老师的一句话，网络通信上绝对的可靠是不存在的。</p></blockquote><h4 id="TCP-Server在干啥？"><a href="#TCP-Server在干啥？" class="headerlink" title="TCP Server在干啥？"></a>TCP Server在干啥？</h4><p>回到我们的应用场景，客户端需要先与服务端建立TCP长连接，并维持这个链接，当服务端产生了新的消息时，服务端主动将新消息发送给客户端，客户端接收消息并解析，然后将结果展示给客户端。</p><blockquote><p>以下例子</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    //vi swoole_tcp_server_demo.php</span><br><span class="line"></span><br><span class="line">    $server = new \swoole_server(&quot;127.0.0.1&quot;,8088,SWOOLE_PROCESS,SWOOLE_SOCK_TCP);</span><br><span class="line"></span><br><span class="line">    $server-&gt;on(&apos;connect&apos;, function ($serv, $fd)&#123;</span><br><span class="line">            echo &quot;Client:Connect.\n&quot;;</span><br><span class="line">            </span><br><span class="line">            //启动一个循环，定时向客户端发一个消息</span><br><span class="line">            </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    $server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123;</span><br><span class="line">            //打印收到的消息</span><br><span class="line">            echo &quot;Receive message: $data&quot;;</span><br><span class="line">            //关闭连接（当然，也可以不关闭）</span><br><span class="line">            $serv-&gt;close($fd);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    $server-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123;</span><br><span class="line">            echo &quot;Client: Close.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$server -&gt; start();</span><br></pre></td></tr></table></figure><blockquote><p>如果你是在远程服务器上运行的，请将127.0.0.1替换为你的远程服务器公网IP（或者你能访问的内网IP）。</p></blockquote><p>上一章的例子中，我们每次receive了一个客户端的消息以后，就关闭了与这个客户端的链接，并没有向客户端发出响应，但事实上，服务端完全可以在收到消息以后，向客户端发出一个回复，就像“请求-&gt;响应”的工作机制一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">//我们修改一下on reveive的回调，然后启动服务</span><br><span class="line">$server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) </span><br><span class="line">&#123;</span><br><span class="line">    //根据收到的消息做出不同的响应</span><br><span class="line">    switch($data)</span><br><span class="line">    &#123;</span><br><span class="line">        case 1:</span><br><span class="line">        &#123;</span><br><span class="line">            $serv-&gt;send($fd,&quot;1 for apple\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 2:</span><br><span class="line">        &#123;</span><br><span class="line">            $serv-&gt;send($fd,&quot;2 for boy\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">            $serv-&gt;send($fd,&quot;Others is default\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用telnet作为客户端访问一下我们刚刚启动Server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; telnet 127.0.0.1 8088</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br></pre></td></tr></table></figure><p>然后分别输入“1”、“2”、“hello”并回车</p><blockquote><p>以下是telnet的输出</p></blockquote><figure class="highlight plain"><figcaption><span>127.0.0.1 8088</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">1</span><br><span class="line">1 for apple</span><br><span class="line">2</span><br><span class="line">2 for boy</span><br><span class="line">3</span><br><span class="line">others is default</span><br><span class="line">5</span><br><span class="line">others is default</span><br><span class="line">hello</span><br><span class="line">others is default</span><br></pre></td></tr></table></figure><p>这段代码很简单，如果receive了客户端的消息，对消息做一个switch，根据switch的结果，向客户端返回不同的消息。</p><blockquote><p>这个场景是一个很典型的“请求-&gt;响应”的场景</p></blockquote><p>那有些盆友也许会问了，这样做的话，跟我使用URL访问网站获取响应有什么区别？</p><blockquote><p>这个问题很好，思考是不断进步的阶梯</p></blockquote><p>那么我们来做些不一样的，继续修改on receive的回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//我们修改一下on reveive的回调，然后启动服务</span><br><span class="line">$server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) </span><br><span class="line">&#123;</span><br><span class="line">    //根据收到的消息做出不同的响应</span><br><span class="line">    switch($data)</span><br><span class="line">    &#123;</span><br><span class="line">        case 1:</span><br><span class="line">        &#123;</span><br><span class="line">            foreach($serv-&gt;connections as $tempFD)</span><br><span class="line">            &#123;</span><br><span class="line">                 # 注: $tempFD 是全体client, $fd 是当前client.</span><br><span class="line">                 $serv-&gt;send($tempFD,&quot;client &#123;$fd&#125; say : 1 for apple\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 2:</span><br><span class="line">        &#123;</span><br><span class="line">            $serv-&gt;send($fd,&quot;2 for boy\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">            $serv-&gt;send($fd,&quot;Others is default\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当case 1的时候，我们遍历了$serv的connections成员，获得了与当前服务器连接的所有客户端，并且向所有的客户端都发送了“1 for apple\n”这个字符串。继续用telnet作为客户端，我们这次需要打开两个telnet，当两个telnet都成功连接了Server之后，用第一个telnet发送1：</p><blockquote><p>第一个telnet客户端的输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; telnet 127.0.0.1 8088</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">1</span><br><span class="line">client 1 say : 1 for apple</span><br></pre></td></tr></table></figure><blockquote><p>第二个telnet客户端的输出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; telnet 127.0.0.1 8088</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">client 1 say : 1 for apple</span><br></pre></td></tr></table></figure><p>第二个telnet客户端虽然并没有向server端发送“1”作为消息，server端仍然向第二个客户端发送了消息“1 for apple\n”，这可以做什么？如果我们要做一个聊天室的话，就可以简单的实现发送公共聊天消息的功能。</p><blockquote><p>如果打开一下脑洞，在Server的业务中将用户分类存储，发送的时候有选择的向不同的用户发送消息，就可以实现私聊，亦或者是分组消息。</p></blockquote><p>如果只是这样，可能又有童鞋问了，仅仅这样做，还是一个“请求-&gt;响应”的工作模式吖，只不过是将一对一的请求响应，变成了一对多的请求响应？</p><blockquote><p>确实有点这个感觉，那我们来做点不一样，这次，server会不断向客户端发送消息，不管有没有请求。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//这次我们要修改的是on connect回调哦！</span><br><span class="line">$server-&gt;on(&apos;connect&apos;, function ($serv, $fd)</span><br><span class="line">&#123;</span><br><span class="line">    $serv-&gt;tick(1000, function() use ($serv, $fd) &#123;</span><br><span class="line">            $serv-&gt;send($fd, &quot;这是一条定时消息\n&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上代码中的tick方法，表示启动一个定时器，该定时器每1000毫秒触发一次，并执行回调方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Swoole Tick是Swoole工具箱中的一个强大工具，它比PHP原生的pcntl_alarm更加精确，也支持异步调用，非常方便，更多介绍可以参考手册。</span><br></pre></td></tr></table></figure><p>这次仍然是打开telnet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; telnet 127.0.0.1 8088</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">2</span><br><span class="line">这是一条定时消息</span><br><span class="line">2 for boy</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br><span class="line">这是一条定时消息</span><br></pre></td></tr></table></figure><p>这次，只要连接上服务器，不管客户端说没说话，会一直收到“这是一条定时消息”的消息，并且，如果我们见缝插针地写个2并发送，就会收到on receive中的反馈“2 for boy”，并不会与“这是一条定时消息”冲突。</p><blockquote><p>这里，前者就是服务端主动发出，客户端被动接受的消息；而后者，却又是“请求-&gt;响应”的工作模式，两者并不冲突，仅取决于具体的代码实现。</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>好滴，今天的三分热度就到这了，再多就得超时了，这篇的内容主要列举了TCP Server的几个基本工作场景，及这些场景通过Swoole Server的简单实现。其实TCP Server的核心应用特征就在于，一旦连接建立，双方都可以平等地自由选择什么时候向对方发出消息，并选择是否对收到的消息做出响应。</p><blockquote><p>想象一下，你跟你的基友在电话两旁自说自话 QAQ</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/szyhf/swoole_study/blob/master/%E5%BD%93SWOOLE%E9%81%87%E4%B8%8ATCP.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载原文&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;前文再续，就书接上一回（拍一下惊堂木，然后喝口茶install一下B），话说笔者当初最早接触Swoole的时候，正迫切的期望能找到一个使用PHP作为主要开发语言的TCP Server的解决方案，因为公司业务中积累了大量的PHP代码，而新增的业务又迫切需要实现与客户端的主动通信，最终在盆友的推荐下，找到了Swoole。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SWOOLE" scheme="http://yoursite.com/tags/SWOOLE/"/>
    
  </entry>
  
  <entry>
    <title>当SWOOLE遇上SERVER</title>
    <link href="http://yoursite.com/2018/09/17/swoole-study-2/"/>
    <id>http://yoursite.com/2018/09/17/swoole-study-2/</id>
    <published>2018-09-17T05:09:12.000Z</published>
    <updated>2019-04-12T09:23:23.722Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/szyhf/swoole_study/blob/master/%E5%BD%93SWOOLE%E9%81%87%E4%B8%8ASERVER.md" target="_blank" rel="noopener">转载原文</a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>上一回讲到，Swoole终于成功邂逅了PHP，现在要开始它们的奇妙路程了。</p><h4 id="Server之初"><a href="#Server之初" class="headerlink" title="Server之初"></a>Server之初</h4><p>通常，我们会把网络系统分为B/S架构和C/S架构<a id="more"></a>，而这里笔者想聊的就是这里提到的S，也就是服务（Server）在干什么？通常，我们会把网络系统分为B/S架构和C/S架构，而这里笔者想聊的就是这里提到的S，也就是服务（Server）在干什么？</p><blockquote><p>风靡各大高校宿舍的Dota和LOL，主体上可以算是典型的C/S架构的网络系统/软件/应用/程序/What ever</p></blockquote><p>这里笔者打算从比较常见的基于PHP的Web网站开始聊起。</p><blockquote><p>这里举例采用的是最基础的Linux + Apache + PHP的开发环境。</p></blockquote><p>当我们打开 <a href="http://127.0.0.1:80" target="_blank" rel="noopener">http://127.0.0.1:80</a> 并看到Apache的欢迎界面时，我们知道，我们已经成功的完成了一个简单的B/S结构的程序。</p><blockquote><p>虽然这里输出的不是Hello World！虽然目前为止一句PHP也没写。</p></blockquote><p>那么，这个时候，这里我们说B/S中的Server具体指代的是什么呢？以下两个选项哪个是你的想法？</p><ol><li>运行并保存着我们网站的服务器主机。</li><li>Apache正在运行的进程。</li></ol><p>其实从笔者的角度而言，上述两个选项都是对的，因为Server这个词本身的含义就很丰富，根据特定的语境，它既可以指服务器，也可以指服务程序。</p><blockquote><p>本文中提到的Server如无特别说明，都是指提供服务的应用程序，在当前的场景中，就是Apache。</p></blockquote><p>我们来简单扒一下，在打开这个网页的过程中，Apache作为一个Server，最少要做到哪些工作？</p><blockquote><p>最基础的工作，更深入的问题我们可以一点点讨论。</p></blockquote><p>首先，Apache需要先运行起来，如果Apache没有运行，显然没法向浏览器提供服务（例如，输出Apache的欢迎页面）</p><blockquote><p>传统的Web网站场景中，Server是被动地提供服务的，也就是客户端不请求，Server就不会提供服务，就像一般民事诉讼中的不告不理原则。</p></blockquote><p>再者，浏览器需要有一个可靠的方法找到我们刚刚运行起来的Apache（就像寄快递，要有收件方的地址）</p><blockquote><p>想象一下市民中心的办证大厅，各种各样的窗口，不同的窗口可以办理不同的证件，市民提交的材料就是“输入”，服务台提供的证件就是“输出”，找到正确的窗口，是享受服务的前题。</p></blockquote><p>例如我们在浏览器输入 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ，我们知道会打开百度的首页。</p><blockquote><p>输入 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> ，会出现404无法访问的错误？</p></blockquote><p>当Apache做到了上述两项工作时，我们可以简单认为它具备了作为一个Server的基础。</p><blockquote><p>用物流管理的话说，就是在“正确的时间、正确的地点、正确的货物”。</p></blockquote><h4 id="监听：正确的地点"><a href="#监听：正确的地点" class="headerlink" title="监听：正确的地点"></a>监听：正确的地点</h4><p>那么，Apache是怎么做到这两点的呢？相信怎么运行Apache这个问题不必笔者啰嗦，我们主要开始看看第二个问题。</p><blockquote><p>关于服务要稳定常驻运行的问题，可参见拙作《守护进程二三事与Supervisor》</p></blockquote><p>我们怎么去定义这个“正确的地点”呢？最常见的方案，就是TCP/IP协议中的IP协议。</p><blockquote><p>严谨地说，TCP协议是传输层协议；IP是网络层协议。因为两者常常搭配出现，就像LAMP一样，有了TCP/IP协议这个说法。</p></blockquote><p>IP协议帮助客户端在浩瀚的网络中找到正确的主机，例如上文中的 127.0.0.1 主机。</p><blockquote><p>127.0.0.1 是IP协议中定义的一个特殊地址，表示本机，概念上有点像PHP中的$this。</p></blockquote><p>如果我们的主机在局域网中被分配的IP是192.168.1.233，则其他主机也可以通过192.168.1.233这个地址找到我们的主机</p><blockquote><p>IP是“IP协议”给每一台联网设备规定一个地址，便于互相通信和发现。</p></blockquote><p>但一个主机如果只能运行一个服务，就太浪费了，因此如果说IP是用来区分不同的联网设备的，Port在这就是用来区分同一个设备的不同服务的。</p><blockquote><p>最基本的LAMP环境中，SSH需要一个端口（默认22），Apahce需要一个端口（默认80），Mysql需要一个端口（默认3306）。</p></blockquote><p>一般情况下，端口的编号取值范围是 [1, 65535]，一般1000以下的端口都会被一些常用服务默认调用，所以尽可能不要使用。</p><blockquote><p>就像大公司电话系统中的主机与分机一样，IP是主机，全世界通用（没有区号这些东西啦），Port就是分机，仅在自己的主机内通用。</p></blockquote><p>写到这里，前文我们提到的 127.0.0.1:80 的含义就更清晰了，前面的 127.0.0.1 是IP地址，后边的80是端口。而因为80是HTTP服务的默认端口，所以访问一般的常见网站时我们并不需要写成 <a href="http://www.baidu.com:80" target="_blank" rel="noopener">www.baidu.com:80</a> 。</p><blockquote><p>所以如果是自建HTTP服务的话，默认情况下还是最好提供80端口作为服务端口。</p></blockquote><p>我们把某个服务通过某个端口对外提供服务的行为称为“监听”，形象的说，前文的Apache监听着本机的80端口，如果有客户通过这个端口发来请求，操作系统就会把请求交给Apache，Apache就可以根据请求的具体内容进行处理，并给出响应（例如，欢迎使用Apache！）。</p><blockquote><p>常用“Listen”或者“Bind”这两个动词。</p></blockquote><p>最后，我们可以整理出简单LAMP环境中，基于HTTP协议的Web服务的交互逻辑：</p><ol><li>客户端（浏览器）将请求提交给指定IP的主机。</li><li>操作系统根据请求中的PORT，转交给监听了这个PORT的Apache。</li><li>Apache根据配置找到合适的目录，并获取目录中的PHP脚本。</li><li>调用Zend对该PHP脚本进行解析，并获得输出结果。</li><li>将输出结果返回给客户端（浏览器）.</li></ol><p>而一般情况下，PHP脚本的工作就在第四步中处理具体业务，至于怎么与浏览器保持通信，PHPer一般是不关心的，直到，Swoole重新定义了PHP。</p><h4 id="Swoole-Server做了什么？"><a href="#Swoole-Server做了什么？" class="headerlink" title="Swoole Server做了什么？"></a>Swoole Server做了什么？</h4><p>前文我们以Apache作为例子，简单梳理了一下Server在做什么的问题，再回来看Swoole Server，就好理解了，Swoole允许通过PHP构造一个新的Server，提供跟Apache类似的功能，监听请求，作出响应。</p><p>那么，我们现在开始第一个简单的Swoole TCP Server的Demo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//vi swoole_server_demo.php</span><br><span class="line">$server = new \swoole_server(&quot;127.0.0.1&quot;, 8088, SWOOLE_PROCESS, SWOOLE_SOCK_TCP);</span><br><span class="line">$server -&gt; start();</span><br></pre></td></tr></table></figure><blockquote><p>后两个参数涉及到了Swoole的运行方式和传输层使用的协议问题，我们以后再聊。</p></blockquote><p>这里我们新建了一个Swoole Server对象，这个对象监听了IP 127.0.0.1，和端口 8088 。然后我们打开浏览器，访问<a href="http://127.0.0.1/swoole_server_demo.php，然后我们会惊讶地发现：报错，swoole_server只能运行在cli模式下。" target="_blank" rel="noopener">http://127.0.0.1/swoole_server_demo.php，然后我们会惊讶地发现：报错，swoole_server只能运行在cli模式下。</a></p><blockquote><p>这是很多童鞋第一次接触Swoole会遇到的另一个问题，还记得我前边说的么？SwooleServer已经是一个独立的服务了，它不再依赖于Apache，它本身就是一个完整的网络Server，所以它需要运行在cli模式下，同时也不需要通过浏览器访问的方式执行了。</p></blockquote><p>所以正确的启动方式应该是在shell中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php swoole_server_demo.php</span><br><span class="line">&gt; PHP Fatal error:  swoole_server::start(): require onReceive/onPacket callback in swoole_server_demo.php</span><br></pre></td></tr></table></figure><blockquote><p>关于cli的问题，可以参考拙作《当Swoole遇上PHP》</p></blockquote><p>这里的报错又是什么原因呢？因为例子中使用的是TCP Server，我们用打电话的例子来梳理一下，客户给服务打电话，对于服务来说，有这么几个关键事件：</p><ol><li>OnConnect，建立连接，也就是电话被拨通的时候发生。</li><li>OnReceive，收到消息，也就是服务听到客户说的话。</li><li>OnClose，关闭连接，也就是客户\服务其中一方挂掉了电话时发生。</li></ol><p>一个完整的TCP服务需要处理这三个过程，而我们访问网页的时候，这些过程都被浏览器\服务程序内部处理掉了，平时写网页的时候只需要考虑对请求作出响应即可。</p><blockquote><p>这种抽象进一步降低了PHP的上手门槛，也让很多人低估了PHP的能力。</p></blockquote><p>而使用Swoole Server的时候，我们需要自己来管理这个过程，同时，也可以在这个基础上做到更多的事情。</p><blockquote><p>所以说学习使用Swoole需要了解更多的是操作系统、计算机网络方面的知识，有相关背景的童鞋学习使用Swoole其实并不困难，了解一下做不同事情需要使用的接口是什么，再了解一下运作机制，就差不多可以上手了。</p></blockquote><p>那我们把这几个回调函数补上，这样就能运行一个完整的Server了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">//vi swoole_server_demo.php</span><br><span class="line">    $server = new \swoole_server(&quot;127.0.0.1&quot;,8088,SWOOLE_PROCESS,SWOOLE_SOCK_TCP);</span><br><span class="line"></span><br><span class="line">    $server-&gt;on(&apos;connect&apos;, function ($serv, $fd)&#123;</span><br><span class="line">            echo &quot;Client:Connect.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">    $server-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123;</span><br><span class="line">            //打印收到的消息</span><br><span class="line">            echo &quot;Receive message: $data&quot;;</span><br><span class="line">            //关闭连接（当然，也可以不关闭）</span><br><span class="line">            $serv-&gt;close($fd);</span><br><span class="line">&#125;);</span><br><span class="line">    $server-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123;</span><br><span class="line">            echo &quot;Client: Close.\n&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$server -&gt; start();</span><br></pre></td></tr></table></figure><p>然后，重新在shell里边执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php swoole_server_demo.php</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>如果一切顺利的话，我们会看到整个命令行好像卡住了，一个光标在闪动，但没有任何输出？这是什么情况？</p><blockquote><p>笔者第一次遇到的时候思路也没转过弯来，一直以为故障了。</p></blockquote><p>这个时候，其实Server已经启动了，并且正在运行，监听了本机的8088端口，此时Server处于等待的状态，所以没有任何输出。</p><blockquote><p>这个时候如果有客户端访问本机的8088端口，就会触发OnConnect事件了。</p></blockquote><p>我们打开另一个交互窗口（注意别关了Swoole Server正在运行的窗口），用telnet来试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在第二个Shell窗口</span><br><span class="line">telnet 127.0.0.1 8088</span><br><span class="line">&gt; Trying 127.0.0.1...</span><br><span class="line">&gt; Connected to 127.0.0.1.</span><br><span class="line">&gt; Escape character is &apos;^]&apos;.</span><br></pre></td></tr></table></figure><p>此时，我们再返回第一个窗口，就会看到刚才卡住的光标有输出了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php swoole_server_demo.php</span><br><span class="line">&gt; Client:Connect.</span><br></pre></td></tr></table></figure><p>输出的正是我们在OnConnect回调中设置的内容。</p><blockquote><p>想想贝尔第一个打通电话的瞬间。</p></blockquote><p>这时我们可以随便输入一些字符看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 在第二个Shell窗口</span><br><span class="line">telnet 127.0.0.1 8088</span><br><span class="line">&gt; Trying 127.0.0.1...</span><br><span class="line">&gt; Connected to 127.0.0.1.</span><br><span class="line">&gt; Escape character is &apos;^]&apos;. </span><br><span class="line">Hello SwooleServer!</span><br><span class="line">&gt; Connection closed by foreign host.</span><br></pre></td></tr></table></figure><p>此时再切换回第一个Shell，我们看到输出增加了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php swoole_server_demo.php</span><br><span class="line">&gt; Client:Connect.</span><br><span class="line">&gt; Receive message: Hello SwooleServer!</span><br><span class="line">&gt; Client: Close.</span><br></pre></td></tr></table></figure><p>OK，我们来看看整个过程发生了什么事：</p><ol><li>运行了一个TCP Server，它监听了 127.0.0.1 主机的 8088 端口。</li><li>用telnet工具作为客户端，它尝试连接 127.0.0.1 主机的 8088 端口 的服务。</li><li>Server收到了连接请求，根据TCP的握手机制完成了连接过程，并触发了OnConnect回调，此时Server端输出了字符串“Client:Connect.\n”</li><li>telnet也获得了连接成功的消息，输出了“Connected to 127.0.0.1.”、“Escape character is ‘^]’.”等消息，此时，相当于电话已经打通了。</li><li>telnet向Server发送了一个字符串“Hello SwooleServer!”。</li><li>Server收到了telnet发来的字符串，并触发了OnReceive回调，在该回调中，Server打印了字符串“Receive message: Hello SwooleServer!”，然后将与telnet的连接关闭了。</li><li>连接关闭后，Server触发OnClose回调，输出了字符串“Client: Close.”。</li><li>连接关闭后，telnet也输出了字符串“Connection closed by foreign host.”</li></ol><p>如果把这个过程弄清楚，那么就朝着Swoole的应用又迈出了一大步。学习Swoole有时候很难，有时候又并不难，难点不在于Swoole的接口有多复杂，机制有多麻烦，而更多在于不知道它到底解决了什么问题，本文笔者对Swoole Server解决的问题做了简单的梳理和介绍，希望能给刚刚接触Swoole的童鞋一点启发和借鉴。</p><h4 id="彪悍的Swoole工具箱"><a href="#彪悍的Swoole工具箱" class="headerlink" title="彪悍的Swoole工具箱"></a>彪悍的Swoole工具箱</h4><p>Swoole具备一系列强大的工具，允许我们借助PHP高效开发的特性，写出高性能的Web服务，那么这个工具箱里除了Swoole Server以外还有什么呢？以下引用自<a href="https://wiki.swoole.com/wiki/page/1.html" target="_blank" rel="noopener">官网的手册</a></p><h5 id="Swoole-Server"><a href="#Swoole-Server" class="headerlink" title="Swoole Server"></a>Swoole Server</h5><p>强大的TCP/UDP Server框架，多线程，EventLoop，事件驱动，异步，Worker进程组，Task异步任务，毫秒定时器，SSL/TLS隧道加密。</p><ul><li>swoole_http_server是swoole_server的子类，内置了Http的支持</li><li>swoole_websocket_server是swoole_http_server的子类，内置了WebSocket的支持</li></ul><h5 id="Swoole-Client"><a href="#Swoole-Client" class="headerlink" title="Swoole Client"></a>Swoole Client</h5><p>TCP/UDP客户端，支持同步并发调用，也支持异步事件驱动。</p><h5 id="Swoole-Event"><a href="#Swoole-Event" class="headerlink" title="Swoole Event"></a>Swoole Event</h5><p>EventLoop API，让用户可以直接操作底层的事件循环，将socket，stream，管道等Linux文件加入到事件循环中。</p><blockquote><p>eventloop接口仅可用于socket类型的文件描述符，不能用于磁盘文件读写</p></blockquote><h5 id="Swoole-Async"><a href="#Swoole-Async" class="headerlink" title="Swoole Async"></a>Swoole Async</h5><p>异步IO接口，提供了 异步文件系统IO，异步DNS查询，异步MySQL等API。包括2个重要的子模块：</p><ul><li>swoole_timer，异步毫秒定时器，可以实现间隔时间或一次性的定时任务</li><li>file，文件系统操作的异步接口</li></ul><h5 id="Swoole-Process"><a href="#Swoole-Process" class="headerlink" title="Swoole Process"></a>Swoole Process</h5><p>进程管理模块，可以方便的创建子进程，进程间通信，进程管理。</p><h5 id="Swoole-Buffer"><a href="#Swoole-Buffer" class="headerlink" title="Swoole Buffer"></a>Swoole Buffer</h5><p>强大的内存区管理工具，像C一样进行指针计算，又无需关心内存的申请和释放，而且不用担心内存越界，底层全部做好了。</p><h5 id="Swoole-Table"><a href="#Swoole-Table" class="headerlink" title="Swoole Table"></a>Swoole Table</h5><p>基于共享内存和自旋锁实现的超高性能内存表。彻底解决线程，进程间数据共享，加锁同步等问题。</p><blockquote><p>swoole_table的性能可以达到单线程每秒读写50W次</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/szyhf/swoole_study/blob/master/%E5%BD%93SWOOLE%E9%81%87%E4%B8%8ASERVER.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载原文&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;上一回讲到，Swoole终于成功邂逅了PHP，现在要开始它们的奇妙路程了。&lt;/p&gt;
&lt;h4 id=&quot;Server之初&quot;&gt;&lt;a href=&quot;#Server之初&quot; class=&quot;headerlink&quot; title=&quot;Server之初&quot;&gt;&lt;/a&gt;Server之初&lt;/h4&gt;&lt;p&gt;通常，我们会把网络系统分为B/S架构和C/S架构&lt;/p&gt;
    
    </summary>
    
    
      <category term="SWOOLE" scheme="http://yoursite.com/tags/SWOOLE/"/>
    
  </entry>
  
  <entry>
    <title>当SWOOLE遇上PHP</title>
    <link href="http://yoursite.com/2018/09/15/swoole-study-1/"/>
    <id>http://yoursite.com/2018/09/15/swoole-study-1/</id>
    <published>2018-09-16T03:09:12.000Z</published>
    <updated>2019-04-12T09:23:23.672Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/szyhf/swoole_study/blob/master/%E5%BD%93SWOOLE%E9%81%87%E4%B8%8APHP.md" target="_blank" rel="noopener">转载原文</a></p><p>一直想写点Swoole的东西，毕竟它重新定义了php，却一直不知道怎么下手写</p><blockquote><p>Swoole涉及的知识点非常多，互为表里，每次想写都发现根本理不出一个头绪</p></blockquote><p>Swoole是一个php的扩展，它的核心目的就是解决php在实现server服务中可能遇到的一系列问题<a id="more"></a>，这些问题用源生的php往往并不能很高效（执行效率）的解决，一般也不会使用php来解决，所以会有说swolle重新定义的php的说法。</p><blockquote><p>毕竟php作为一门成熟的脚本语言，开发效率是先天优势。</p></blockquote><p>扩展的英文名称是Extension，php扩展是用C语言作为开发语言，基于Zend引擎提供的API，编译成的一个动态库。</p><blockquote><p>如果曾经做过类似动态库调用开发的童鞋可能会更好理解一些，例如Android中的NDK开发</p></blockquote><p>在php的配置文件中配置好extension的属性后，就可以引用这个动态库了。</p><blockquote><p>也就是说，swoole本身是用C语言编写的，它可以让php获得一些额外的function。</p></blockquote><p>然后是运行方式，swoole的许多功能都只能运行在cli模式下，而cli模式往往是很多刚接触swoole的phper遇到的第一个问题。</p><blockquote><p>我当初学习swoole的时候也在cli这里栽了个大跟头</p></blockquote><p>我们现在整理一下最常见的php代码执行方式：</p><ol><li>安装apache、php</li><li>配置apache对那个目录进行php解析</li><li>用浏览器访问那个目录的php文件</li></ol><blockquote><p>更多的细节这里就不提了，毕竟我相信每个phper对这个都是很熟悉的。</p></blockquote><p>但这里就开始出现了第一个问题，我们知道，php是一个脚本语言，脚本语言的核心特点在于不用编译，随时执行，而执行脚本的工具就是解析器，而php的解析器就是zend引擎。</p><blockquote><p>严格来说，zend并不是唯一的选择，不过，zend是最官方的。另外，Zend Studio和Zend Engine不是同一个东西，本文中的Zend全部指Zend Engine。</p></blockquote><p>换个角度讲，只要有解析器，写好的php脚本就是可以执行的，而zend引擎与apache之间并没有绝对的关系</p><blockquote><p>实际上，apahce是调用了zend对php脚本进行执行，然后将执行结果输出给了浏览器</p></blockquote><p>所以所谓cli模式（CommandLine，命令行模式），其实就是在命令行下直接调用zend引擎对php脚本进行解析并执行，并获得程序输出结果的php脚本执行方式。</p><blockquote><p>其实php也可以作为shell脚本来使用哦，就像bash shell一样</p></blockquote><p>既然问题讲清楚了，在一个系统中具体怎么操作呢？</p><blockquote><p>本文以CentOS 7.5作为系统环境，swoole是针对linux系统开发的，windows下并不适用。学习swoole的一个前题是懂得基本的linux系统使用。</p></blockquote><p>当安装好php的时候，找到php的安装目录，如果是默认安装的话，可以试试whereis命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 某种简单的方法</span><br><span class="line">whereis php</span><br><span class="line">&gt; /usr/local/bin/php;</span><br></pre></td></tr></table></figure><blockquote><p>locate whereis find这些命令都可以试试，目的是找到php</p></blockquote><p>然后我们来写一个最经典的php脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//vi hello_cli.php</span><br><span class="line">&lt;?php</span><br><span class="line">    echo &apos;Hello PHP Cli&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>编写纯php脚本时，php标签不要封口</p></blockquote><p>然后我们在shell里执行它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/php hello_cli.php</span><br><span class="line">&gt; Hello PHP Cli</span><br></pre></td></tr></table></figure><blockquote><p>这段代码中的第一个php，是一个可执行文件，它接受一个php脚本文件作为输入参数，并解析执行这个php脚本文件（通过zend）。</p></blockquote><p>没有错，第一个cli模式下的php程序就被你执行成功了！</p><blockquote><p>默认情况下，php都会被安装在了$PATH的目录下，那就可以直接省略路径前缀了，下文中调用php的时候，全都省略了路径前缀。</p></blockquote><p>因为swoole是pecl的项目，所以使用pecl安装是最简单的方法，强烈推荐第一次接触的童鞋先使用pecl安装，在熟悉了swoole之后，再考虑使用编译安装的方式以获取更多进阶功能。</p><blockquote><p>pecl这个工具基本都会被安装在与php相同的目录下（往往也都是$PATH目录）</p></blockquote><blockquote><p>pecl install swoole</p></blockquote><p>执行以下命令查看是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php -m | grep swoole</span><br><span class="line">&gt; swoole</span><br></pre></td></tr></table></figure><p>如果正确的输出了swoole，那么恭喜你，这次安装很成功</p><blockquote><p>另一个常见的比较麻烦的问题是，有些童鞋的电脑里安装了多个php，而安装的时候没有正确的安装到预期的php的扩展目录中，就会导致无法正常工作，解决方案就是弄清楚各个php安装目录及配置关系，选择正确的目录进行安装。</p></blockquote><p>其实本文还没正式开始介绍swoole，都是在学习swoole之前的准备工作，swoole的上手门槛比一般的php应用要高的多，如果没有网络开发和操作系统方面的一些知识，学习它并不是一件容易的事情，学习曲线很陡峭。</p><p>很多新手会诟病swoole的手册写的太模糊，其实是前置知识不足，而手册也给出了需要的前置知识列表，以下引用至官网的手册-学习swoole需要哪些知识？</p><h4 id="多进程-多线程"><a href="#多进程-多线程" class="headerlink" title="多进程/多线程"></a>多进程/多线程</h4><ul><li>了解Linux操作系统进程和线程的概念</li><li>了解Linux进程/线程切换调度的基本知识</li><li>了解进程间通信的基本知识，如管道、UnixSocket、消息队列、共享内存</li></ul><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><ul><li>了解SOCKET的基本操作如accept/connect、send/recv、close、listen、bind</li><li>了解SOCKET的接收缓存区、发送缓存区、阻塞/非阻塞、超时等概念</li></ul><h4 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h4><ul><li>了解select/poll/epoll</li><li>了解基于select/epoll实现的事件循环，Reactor模型</li><li>了解可读事件、可写事件</li></ul><h4 id="TCP-IP网络协议"><a href="#TCP-IP网络协议" class="headerlink" title="TCP/IP网络协议"></a>TCP/IP网络协议</h4><ul><li>了解TCP/IP协议</li><li>了解TCP、UDP传输协议</li></ul><h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><ul><li>使用gdb调试Linux程序</li><li>使用strace跟踪进程的系统调用</li><li>使用tcpdump跟踪网络通信过程</li><li>其他Linux系统工具，如ps、lsof、top、vmstat、netstat、sar、ss等</li></ul><p>学习并理解一个新事务并不是一个容易的事情，特别对于swoole这种具备一定颠覆性的工具，要有耐心和实践。</p><blockquote><p>淡定的把手册看完，遇到不理解的名字学会使用搜索引擎学习，swoole的手册其实是个大宝库，网络开发常见的问题其实里边都涉及到了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/szyhf/swoole_study/blob/master/%E5%BD%93SWOOLE%E9%81%87%E4%B8%8APHP.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一直想写点Swoole的东西，毕竟它重新定义了php，却一直不知道怎么下手写&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Swoole涉及的知识点非常多，互为表里，每次想写都发现根本理不出一个头绪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Swoole是一个php的扩展，它的核心目的就是解决php在实现server服务中可能遇到的一系列问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="SWOOLE" scheme="http://yoursite.com/tags/SWOOLE/"/>
    
  </entry>
  
  <entry>
    <title>PHP完善的Error/ Exception的捕获与处理</title>
    <link href="http://yoursite.com/2018/09/09/php-error/"/>
    <id>http://yoursite.com/2018/09/09/php-error/</id>
    <published>2018-09-09T05:09:12.000Z</published>
    <updated>2019-04-12T09:23:19.735Z</updated>
    
    <content type="html"><![CDATA[<p>PHP（PHP_VERSION &gt;= 7） 的 Error / Exception 的捕获与处理还是值得一说的<a id="more"></a>，优雅处理错误与异常，在提升框架友好度的同时，也提升了开发效率。</p><h3 id="PHP-错误等级"><a href="#PHP-错误等级" class="headerlink" title="PHP 错误等级"></a>PHP 错误等级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 系统级用户代码的一些错误类型 可由 try ... catch ... 捕获</span><br><span class="line">E_PARSE          解析时错误 语法解析错误 少个分号 多个逗号一类的 致命错误</span><br><span class="line">E_ERROR          运行时错误 比如调用了未定义的函数或方法 致命错误</span><br><span class="line"></span><br><span class="line"># 系统级用户代码的一些错误类型 可由 set_error_handler 捕获处理</span><br><span class="line">E_WARNING        运行时警告 调用了未定义的变量</span><br><span class="line">E_NOTICE         运行时提醒                  </span><br><span class="line">E_DEPRECATED     运行时已废弃的函数或方法</span><br><span class="line"></span><br><span class="line"># 用户级自定义错误 可由 trigger_error 触发 可由 set_error_handler 捕获处理</span><br><span class="line">E_USER_ERROR      用户自定义错误 致命错误 未处理也会导致程序退出</span><br><span class="line">E_USER_WARNING</span><br><span class="line">E_USER_NOTICE</span><br><span class="line">E_USER_DEPRECATED</span><br><span class="line"></span><br><span class="line">==========================开发中常遇到/不常遇到分割线=======================</span><br><span class="line"></span><br><span class="line"># Zend Engine 内部的一些错误 应该也能通过 try ... catch ... 捕获 略难测试</span><br><span class="line">E_CORE_ERROR</span><br><span class="line">E_CORE_WARNING</span><br><span class="line">E_COMPILE_ERROR</span><br><span class="line">E_COMPILE_WARNING</span><br><span class="line"></span><br><span class="line">#编码标准化警告(建议如何修改以向前兼容)</span><br><span class="line">E_STRICT          部分 try ... catch ... 部分 set_error_handler</span><br><span class="line">E_RECOVERABLE_ERROR</span><br></pre></td></tr></table></figure><p>以上为 PHP 的一些错误监听级别，常用于 error_reporting 和 set_error_handler 的监听级别设定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(E_ALL &amp; ~E_NOTICE);</span><br><span class="line"></span><br><span class="line">set_error_handler(function handler($error_no, $error_msg, $error_file, $error_line) &#123;</span><br><span class="line">&#125;, E_ALL | E_STRICT);</span><br></pre></td></tr></table></figure><p>PHP 的错误处理可以分为：<em>用户自定义错误处理</em> 和 <em>PHP标准错误处理</em>，两者的关系相当于两层错误捕捉器，系统会先检测是否定义了 用户自定义错误处理，否则会将错误交由 PHP标准错误处理 进行处理。</p><p>注意：PHP 的所有的 Exception 都属于 E_ERROR 级的错误，抛出时如果没有被捕获而交由 PHP 标准错误处理的话，就会 Fatal Error 导致程序退出执行。当然，PHP7 为了细化错误级别，划分了 Error 级 Error 的衍生类，这些也都属于 E_ERROR 级别的错误。</p><h3 id="PHP-标准错误处理"><a href="#PHP-标准错误处理" class="headerlink" title="PHP 标准错误处理"></a>PHP 标准错误处理</h3><p>PHP 标准错误处理是在一些错误没有被用户捕获处理（没有被 try … catch … 或 set_error_handler 捕获处理）时，错误 会递交至 PHP 标准错误处理。相关的设置项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 监听捕获的错误级别</span><br><span class="line">error_reporting(E_ALL);</span><br><span class="line"></span><br><span class="line">// 是否开启错误信息回显 将错误输出至标准输出（浏览器/命令行）</span><br><span class="line">ini_set(&apos;display_errors&apos;, true);</span><br><span class="line"></span><br><span class="line">// 死否开启错误日志记录 将错误记录至 ini：error_log 指定文件</span><br><span class="line">ini_set(&apos;log_errors&apos;, true);</span><br><span class="line">ini_set(&apos;error_log&apos;, __DIR__ . &apos;/php-errors.log&apos;);</span><br></pre></td></tr></table></figure><h4 id="1、error-reporting-level"><a href="#1、error-reporting-level" class="headerlink" title="1、error_reporting([level])"></a>1、error_reporting([level])</h4><p>获取或设定当前错误的监听级别。要注意，是获取或设定的 PHP 标准错误处理 的级别，不会有效于 try…catch… 或 set_error_handler。</p><h4 id="2、display-errors"><a href="#2、display-errors" class="headerlink" title="2、display_errors"></a>2、display_errors</h4><p>是否将错误信息回显至标准输出。默认开启，生产环境下强烈建议 关闭 此项。</p><h4 id="3、log-errors"><a href="#3、log-errors" class="headerlink" title="3、log_errors"></a>3、log_errors</h4><p>是否记录错误日志。默认关闭，生产环境下强烈建议 开启 此项。</p><h4 id="4、error-log"><a href="#4、error-log" class="headerlink" title="4、error_log"></a>4、error_log</h4><p>错误日志的保存文件。注意：如果路径无效，display_errors 会被强制开启。</p><h3 id="PHP-用户自定义错误处理"><a href="#PHP-用户自定义错误处理" class="headerlink" title="PHP 用户自定义错误处理"></a>PHP 用户自定义错误处理</h3><h4 id="1、set-error-handler"><a href="#1、set-error-handler" class="headerlink" title="1、set_error_handler"></a>1、set_error_handler</h4><p>set_error_handler 并非可以捕获所有错误，且 set_error_handler 不会终止程序继续执行。处理后若返回 false，则错误会被继续递交给 PHP 标准错误处理 流程。</p><p>可以捕获： E_WARNING &amp; E_NOTICE &amp; E_DEPRCATED &amp; E_USER_<em> &amp; 部分 E_STRICT 级的错误。<br>无法捕获： E_ERROR &amp; E_PARSE &amp; E_CORE_</em> &amp; E_COMPLIE_* 级的错误。</p><p>有自身的错误捕获级别，默认E_ALL | E_STRICT，且不受 error_reporting 设定的级别的影响。这里要理解，用户自定义错误处理 和 PHP 标准错误处理 是两层错误捕捉器，有独立的捕获级别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 用户自定义错误处理</span><br><span class="line">set_error_handler(function ($error_no, $error_msg, $error_file, $error_line) &#123;</span><br><span class="line">    switch ($error_no) &#123;</span><br><span class="line">        case E_WARNING:</span><br><span class="line">            $level_tips = &apos;PHP Warning: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_NOTICE:</span><br><span class="line">            $level_tips = &apos;PHP Notice: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_DEPRECATED:</span><br><span class="line">            $level_tips = &apos;PHP Deprecated: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_USER_ERROR:</span><br><span class="line">            $level_tips = &apos;User Error: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_USER_WARNING:</span><br><span class="line">            $level_tips = &apos;User Warning: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_USER_NOTICE:</span><br><span class="line">            $level_tips = &apos;User Notice: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_USER_DEPRECATED:</span><br><span class="line">            $level_tips = &apos;User Deprecated: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_STRICT:</span><br><span class="line">            $level_tips = &apos;PHP Strict: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            $level_tips = &apos;Unkonw Type Error: &apos;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // do some handle</span><br><span class="line">    $error = $level_tips . $error_msg . &apos; in &apos; . $error_file . &apos; on &apos; . $error_line;</span><br><span class="line">    echo $error . PHP_EOL;</span><br><span class="line"></span><br><span class="line">    // 如果 return false 则错误会继续递交给 PHP 标准错误处理</span><br><span class="line">    // return false;</span><br><span class="line">&#125;, E_ALL | E_STRICT);</span><br><span class="line"></span><br><span class="line">trigger_error(&quot;用户自定义 notice error&quot;);</span><br><span class="line">trigger_error(&quot;用户自定义 warning error&quot;, E_USER_WARNING);</span><br><span class="line">trigger_error(&quot;用户自定义 deprecated error&quot;, E_USER_DEPRECATED);</span><br><span class="line">trigger_error(&quot;用户自定义 fatal error&quot;, E_USER_ERROR);</span><br></pre></td></tr></table></figure><h4 id="2、trigger-error"><a href="#2、trigger-error" class="headerlink" title="2、trigger_error"></a>2、trigger_error</h4><p>trigger_error 用来触发用户级别的自定义错误，可以使用 set_error_handler 捕获处理。<br>默认的错误级别是 E_USER_NOTICE，我们可以自定义。<br>这里需要注意的是：E_USER_ERROR 级别的错误如果被 PHP 标准错误处理 捕获，脚本也会退出执行错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(E_ALL);</span><br><span class="line">ini_set(&apos;display_errors&apos;, true);</span><br><span class="line"></span><br><span class="line">trigger_error(&apos;用户自定义 notice error&apos;, E_USER_NOTICE);</span><br><span class="line">echo &apos;continue A&apos; . PHP_EOL;</span><br><span class="line">trigger_error(&apos;用户自定义 warning error&apos;, E_USER_WARNING);</span><br><span class="line">echo &apos;continue B&apos; . PHP_EOL;</span><br><span class="line">trigger_error(&apos;用户自定义 deprecated error&apos;, E_USER_DEPRECATED);</span><br><span class="line">echo &apos;continue C&apos; . PHP_EOL;</span><br><span class="line">trigger_error(&apos;用户自定义 fatal error&apos;, E_USER_ERROR);</span><br><span class="line">echo &apos;D point will not be executed&apos; . PHP_EOL;</span><br></pre></td></tr></table></figure><h4 id="3、set-exception-handler"><a href="#3、set-exception-handler" class="headerlink" title="3、set_exception_handler"></a>3、set_exception_handler</h4><p>set_exception_handler 用户自定义捕获异常 handler，异常没有被 try … catch 捕获处理的话会被抛出，此时系统会检查上下文是否注册了 set_exception_handler。<br>如果未注册 则进入 PHP 标准错误处理 致命错误退出执行。<br>如果已注册 则进入 set_exception_handler 处理 程序依然会退出执行。<br>而 try … catch … 捕获异常后仍不会退出执行，故强烈建议将有异常的执行逻辑放入 try … catch 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 捕获异常后程序会退出执行</span><br><span class="line">set_exception_handler(function ($exception) &#123;</span><br><span class="line">    echo $exception;</span><br><span class="line">    // 此处程序会退出执行 异常到此结束 并不会交给 PHP 标准异常处理</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">throw new Exception(&apos;hello world!&apos;);</span><br><span class="line"></span><br><span class="line">echo &apos;will i be executed？&apos;;</span><br></pre></td></tr></table></figure><h4 id="4、try-…-catch-…"><a href="#4、try-…-catch-…" class="headerlink" title="4、try … catch …"></a>4、try … catch …</h4><p>开发中用户层面的 set_error_hanlder 无法捕获的错误还剩下 E_ERROR 和 E_PARSE 两个级别，使用 try … catch … 则可以将这俩货捕捉到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">来个小插曲：大家对 E_PARSE 熟悉又陌生，可能经常遇到（各大框架都有此级别错误捕获提示），但自己不知道如何捕获，其实首先要理解 E_PARSE 错误的发生时段。</span><br><span class="line"></span><br><span class="line">E_PARSE：即语法解析错误，Syntax Error then Parse Error，PHP 将脚本载入 Zend Engine 后，最开始要做的就是检查基本语法是否有误，无误才会调用解释器，一行行的开始解释运行。</span><br><span class="line"></span><br><span class="line">这里就有个鸡生蛋，蛋生鸡的问题了。如下代码：</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">//认为关闭了错误捕获 不应该有错误报出才对</span><br><span class="line">error_reporting(0);</span><br><span class="line"></span><br><span class="line">echo &apos;i lose semicolon&apos;</span><br><span class="line">然后很多人会诧异，明明关闭了错误提示，为什么还会报错？</span><br><span class="line"></span><br><span class="line">没错，代码的确正确的书写了关闭错误提示的意图。但还没被执行到时，脚本就因为最初始的语法解析错误，被 Zend Engine 抛出 Parse Error 终止执行了。同时还要理解，PHP include / require 只有在真的解释到这一行代码时，引用的文件才会被载入--解析--解释执行。</span><br><span class="line"></span><br><span class="line">所以，我们需要有一个无错的 try ... catch ... 容器，在容器中便可以对后续引用的外部脚本进行 E_PARSE 错误捕捉。</span><br><span class="line"></span><br><span class="line">例如框架自身是一个无错的运行容器，开发者自写的 MVC 是被 include / require 到此容器中 解析 -- 解释执行 的，用户代码的语法错误即会被容器的 try ... catch ... 优雅的捕获到。</span><br></pre></td></tr></table></figure><p>try … catch … 的错误捕获级别同样不受 error_reporting 影响，我们可以通过 多层 catch 细化各类型的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">// typeError demo</span><br><span class="line">function foo(): int</span><br><span class="line">&#123;</span><br><span class="line">    return &apos;hello world&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    //foo();</span><br><span class="line">    // echo strlen(&apos;hello world&apos;, 233);</span><br><span class="line">&#125; catch (\ErrorException $errorException) &#123;</span><br><span class="line">    // 捕获错误异常</span><br><span class="line">    echo &apos;ErrorException: &apos; . $errorException . PHP_EOL;</span><br><span class="line">&#125; catch (\Exception $exception) &#123;</span><br><span class="line">    // 捕获异常</span><br><span class="line">    echo &apos;Exception: &apos; . $exception . PHP_EOL;</span><br><span class="line">&#125; catch (\TypeError $typeError) &#123;</span><br><span class="line">    // 捕获类型错误 返回值/参数不正确</span><br><span class="line">    echo &apos;Type Error: &apos; . $typeError . PHP_EOL;</span><br><span class="line">&#125; catch (\ParseError $parseError) &#123;</span><br><span class="line">    // 捕获解析错误 语法错误</span><br><span class="line">    echo &apos;Parse Error: &apos; . $parseError . PHP_EOL;</span><br><span class="line">&#125; catch (\DivisionByZeroError $divisionByZeroError) &#123;</span><br><span class="line">    // 除 0 无法捕获 但 除 0 取余可以捕获 = = 很无奈</span><br><span class="line">    echo &apos;Division By Zero Error: &apos; . $divisionByZeroError . PHP_EOL;</span><br><span class="line">&#125; catch (\Error $error) &#123;</span><br><span class="line">    // 基本错误</span><br><span class="line">    echo &apos;Error: &apos; . $error . PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是，DivisionByZeroError 在 PHP7 中依然无法隐式的完美捕获。准确的说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 x / 0 时抛出一个 E_WARNING 级别的错误，我们可以 set_error_handler 捕获，然后再判断错误为</span><br><span class="line">&apos;Devision by zero&apos; 时抛出一个 ErrorException 的异常交由 try ... catch ... 捕获处理即可。</span><br><span class="line">当 x % 0 时才会直接抛出 DivisionByZeroError 的错误。</span><br></pre></td></tr></table></figure><p>当然，你也可以显示的判断除数为 0 来决定是否抛出个 DivisionByZeroError</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">try &#123;</span><br><span class="line">    $divisor = 0;</span><br><span class="line">    if ($divisor == 0) &#123;</span><br><span class="line">        throw new DivisionByZeroError(&apos;Division by zero！&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    echo 233 / $divisor;</span><br><span class="line">&#125; catch (\DivisionByZeroError $error) &#123;</span><br><span class="line">    echo $error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PHP-预定义的-Error-和-Exception"><a href="#PHP-预定义的-Error-和-Exception" class="headerlink" title="PHP 预定义的 Error 和 Exception"></a>PHP 预定义的 Error 和 Exception</h3><p>Predefined Exceptions 预定义异常 可由系统自动抛出<br><a href="http://php.net/manual/en/reserved.exceptions.php" target="_blank" rel="noopener">http://php.net/manual/en/reserved.exceptions.php</a>  </p><blockquote><p>Exception<br> ErrorException<br> Error<br> ArgumentCountError<br> ArithmeticError<br> AssertionError<br> DivisionByZeroError<br> ParseError<br> TypeError  </p></blockquote><p> SPL Exceptions SPL 标准规范异常 可供开发者规范代码自行抛出<br> <a href="http://php.net/manual/en/spl.exceptions.php" target="_blank" rel="noopener">http://php.net/manual/en/spl.exceptions.php</a>  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BadFunctionCallException</span><br><span class="line">BadMethodCallException</span><br><span class="line">DomainException</span><br><span class="line">InvalidArgumentException</span><br><span class="line">LengthException</span><br><span class="line">LogicException</span><br><span class="line">OutOfBoundsException</span><br><span class="line">OutOfRangeException</span><br><span class="line">OverflowException</span><br><span class="line">RangeException</span><br><span class="line">RuntimeException</span><br><span class="line">UnderflowException</span><br><span class="line">UnexpectedValueException</span><br></pre></td></tr></table></figure><h3 id="完善的错误和异常捕获"><a href="#完善的错误和异常捕获" class="headerlink" title="完善的错误和异常捕获"></a>完善的错误和异常捕获</h3><p> 下面的代码基本呈现和捕获了 PHP7 提供的所有预定义错误和异常 及 PHP 标准错误处理<br> 1、使用 try … catch 捕获 E_ERROR 及 E_PARSE 级别的 Error (及Error 类的衍生类) 和 Exception (ErrorException)。<br> 2、对于 try … catch 无法捕获的 E_WARNING，E_NOTICE，E_DEPRECATED，E_USER_*，部分 E_STRICTED 级别的错误，我们使用 set_error_handler 捕获处理，捕获后我们其实可以将错误信息封装到 ErrorException 中并抛出，这样处理流又会交给 try … catch，可以统一处理，比如Yii2框架就是这样处理的。<br> 3、set_exception_handler 则是捕获在没有 try … catch 中执行的代码的异常，所以强烈建议一些存在异常 风险的逻辑要放入 try … catch 中。  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// php &gt;= 7</span><br><span class="line">// PHP 标准错误处理 捕获级别</span><br><span class="line">error_reporting(E_ALL);</span><br><span class="line">// 是否将 标准错误处理 捕获的错误回显在 stdout 上</span><br><span class="line">ini_set(&apos;display_errors&apos;, false);</span><br><span class="line">// 开启错误日志</span><br><span class="line">ini_set(&apos;log_errors&apos;, true);</span><br><span class="line">// 如果错误日志路径无效 display_errors 依然会强制打开</span><br><span class="line">ini_set(&apos;error_log&apos;, __DIR__ . &apos;/php-errors.log&apos;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * set_error_handler 用户自定义错误 handler</span><br><span class="line"> * 能够捕获 E_WARNING E_NOTICE E_DEPRECATED E_USER_* E_STRICT 级的错误</span><br><span class="line"> * 无法捕获 E_ERROR E_PARSE E_CORE_* E_COMPILE_* [DivisionByZeroError TypeError] 级的错误</span><br><span class="line"> */</span><br><span class="line">set_error_handler(function ($error_no, $error_msg, $error_file, $error_line) &#123;</span><br><span class="line">    switch ($error_no) &#123;</span><br><span class="line">        case E_WARNING:</span><br><span class="line">            // x / 0 错误 PHP7 依然不能很友好的自动捕获 只会产生 E_WARNING 级的错误</span><br><span class="line">            // 捕获判断后 throw new DivisionByZeroError($error_msg)</span><br><span class="line">            // 或者使用 intdiv(x, 0) 方法 会自动抛出 DivisionByZeroError 的错误</span><br><span class="line">            if (strcmp(&apos;Division by zero&apos;, $error_msg) == 0) &#123;</span><br><span class="line">                throw new \DivisionByZeroError($error_msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $level_tips = &apos;PHP Warning: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_NOTICE:</span><br><span class="line">            $level_tips = &apos;PHP Notice: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_DEPRECATED:</span><br><span class="line">            $level_tips = &apos;PHP Deprecated: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_USER_ERROR:</span><br><span class="line">            $level_tips = &apos;User Error: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_USER_WARNING:</span><br><span class="line">            $level_tips = &apos;User Warning: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_USER_NOTICE:</span><br><span class="line">            $level_tips = &apos;User Notice: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_USER_DEPRECATED:</span><br><span class="line">            $level_tips = &apos;User Deprecated: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        case E_STRICT:</span><br><span class="line">            $level_tips = &apos;PHP Strict: &apos;;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            $level_tips = &apos;Unkonw Type Error: &apos;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // do some handle</span><br><span class="line">    $error = $level_tips . $error_msg . &apos; in &apos; . $error_file . &apos; on &apos; . $error_line;</span><br><span class="line">    echo $error . PHP_EOL;</span><br><span class="line">    </span><br><span class="line">    // or throw a ErrorException back to try ... catch block</span><br><span class="line">    // throw new \ErrorException($error);</span><br><span class="line">    </span><br><span class="line">    // 如果 return false 则错误会继续递交给 PHP 标准错误处理</span><br><span class="line">    // return false;</span><br><span class="line">&#125;, E_ALL | E_STRICT);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * set_exception_handler 用户自定义捕获异常 handler</span><br><span class="line"> * 异常没有被 try ... catch ... 捕获处理的话会被抛出</span><br><span class="line"> * 此时系统会检查上下文是否注册了 set_exception_handler</span><br><span class="line"> * 如果未注册 则进入 PHP 标准异常处理 致命错误退出执行</span><br><span class="line"> * 如果已注册 则进入 set_exception_handler 处理 程序依然会退出执行</span><br><span class="line"> * 而 try ... catch ... 捕获异常后仍不会退出执行</span><br><span class="line"> * 故强烈建议将有异常的执行逻辑放入 try ... catch 中</span><br><span class="line"> */</span><br><span class="line">set_exception_handler(function ($exception) &#123;</span><br><span class="line">    echo $exception;</span><br><span class="line">    // 此处程序会退出执行 异常到此结束 并不会交给 PHP 标准异常处理</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// type error demo</span><br><span class="line">function foo(): int</span><br><span class="line">&#123;</span><br><span class="line">    return &apos;result type error&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 捕获 E_ERROR E_PARSE 级的 Error</span><br><span class="line">// 捕获 Exception</span><br><span class="line">try &#123;</span><br><span class="line">    // 加载外部文件的正确写法</span><br><span class="line">    $file = __DIR__ . &apos;/bar.inc.php&apos;;</span><br><span class="line">    if (file_exists($file)) &#123;</span><br><span class="line">        require_once $file;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new Exception($file . &apos; not exists!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ParseError 解析错误</span><br><span class="line">    // bar.inc.php 的内容要有基本的语法错误: &lt;?php echo &apos;some syntax error&apos;</span><br><span class="line"></span><br><span class="line">    // ArgumentCountError extends TypeError PHP &gt;= 7.1.0</span><br><span class="line">    // strlen 参数错误</span><br><span class="line">    echo strlen(&apos;hello world&apos;, 4);</span><br><span class="line">    </span><br><span class="line">    // TypeError 类型错误</span><br><span class="line">    // foo 要求的返回类型为 int 但 return 了 string 类型错误</span><br><span class="line">    foo();</span><br><span class="line">    </span><br><span class="line">    // DivisionByZeroError extends ArithmeticError</span><br><span class="line">    // x / 0 会抛出 E_WARNING 的异常 但不会自动抛出 DivisionByZeroError</span><br><span class="line">    // 我们可以使用 set_error_handler 进行捕获然后手动抛出 DivisionByZeroError</span><br><span class="line">    1 / 0;</span><br><span class="line">    // Integer Divison 等同于 1 / 0 可以直接抛出 DivisionByZeroError</span><br><span class="line">    intdiv(1, 0);</span><br><span class="line">    // 除 0 取余 可以直接抛出 DivisionByZeroError</span><br><span class="line">    1 % 0;</span><br><span class="line"></span><br><span class="line">    // ArithmeticError 错误</span><br><span class="line">    intdiv(PHP_INT_MIN, -1);</span><br><span class="line">    </span><br><span class="line">    // AssertionError 断言错误</span><br><span class="line">    assert(&apos;1 != 1&apos;);</span><br><span class="line"></span><br><span class="line">    // 调用未定义的函数 错误级别：E_ERROR</span><br><span class="line">    bar();</span><br><span class="line">&#125; catch (\ErrorException $errorException) &#123;</span><br><span class="line">    // 错误异常</span><br><span class="line">    // 最常用的就是将那几个非致命的错误捕获后 ErrorException 回抛到 try ... catch 中</span><br><span class="line">    echo &apos;ErrorException: &apos; . $errorException . PHP_EOL;</span><br><span class="line">&#125; catch (\Exception $exception) &#123;</span><br><span class="line">    // 异常</span><br><span class="line">    echo &apos;Exception: &apos; . $exception . PHP_EOL;</span><br><span class="line">&#125; catch (\ParseError $parseError) &#123;</span><br><span class="line">    // 解析错误 语法错误</span><br><span class="line">    echo &apos;Parse Error: &apos; . $parseError . PHP_EOL;</span><br><span class="line">&#125; catch (\ArgumentCountError $argumentCountError ) &#123;</span><br><span class="line">    // 传参非法错误 php &gt;= 7.1.0</span><br><span class="line">    echo &apos;Argument Count Error: &apos; . $argumentCountError . PHP_EOL;</span><br><span class="line">&#125; catch (\TypeError $typeError) &#123;</span><br><span class="line">    // 类型错误 返回值</span><br><span class="line">    echo &apos;Type Error: &apos; . $typeError . PHP_EOL;</span><br><span class="line">&#125; catch (\DivisionByZeroError $divisionByZeroError) &#123;</span><br><span class="line">    // x / 0 不抛出  x % 0 可以抛出</span><br><span class="line">    // x / 0 可以用 intdiv(x, 0) 代替 会抛出</span><br><span class="line">    echo &apos;Division By Zero Error: &apos; . $divisionByZeroError . PHP_EOL;</span><br><span class="line">&#125; catch (\ArithmeticError $arithmeticError) &#123;</span><br><span class="line">    // 算数运算错误 intdiv(PHP_INT_MIN, -1) 触发</span><br><span class="line">    echo &apos;Arithmetic Error: &apos; . $arithmeticError . PHP_EOL;</span><br><span class="line">&#125; catch (\AssertionError $assertionError) &#123;</span><br><span class="line">    // 断言错误</span><br><span class="line">    echo &apos;Assertion Error: &apos; . $assertionError . PHP_EOL;</span><br><span class="line">&#125; catch (\Error $error) &#123;</span><br><span class="line">    // 基本错误</span><br><span class="line">    echo &apos;Error: &apos; . $error . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;run finished!&quot; . PHP_EOL;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 1、PHP 允许用户自定义 Error 和 Exception 的捕获与处理。如用户未捕获处理，则会递交给 PHP 标准错/异常处理，根据 errror_reporting display_errors log_erros error_log 参数决定处理方式。生产环境应关闭 display_errors 同时开启 log_errors 记录错误日志。</p><p> 2、set_error_handler 可以捕获 E_WARNING &amp; E_NOTICE &amp; E_DEPRECATED &amp; E_USER_* 和 部分 E_STRICT 级的错误。set_error_handler 如果返回了 false 错误会递交给 PHP 标准错误处理。set_error_handler 不会终止程序执行。</p><p> 3、trigger_error 可以用来抛出用户级的错误，且 E_USER_ERROR 效用等同于 E_ERROR，PHP 标准错误处理 捕获此级别的错误时会终止程序执行。</p><p> 4、set_exception_handler 用户自定义异常捕获，捕获后程序依然会终止运行，但不会再将异常递交给 PHP 标准异常处理。</p><p> 5、try … catch 可以捕获所有的 Exception 和 E_ERROR &amp; E_PARSE 级的错误。程序不会退出执行。</p><p> 6、PHP 自带了一些 Predefined Exceptions，同时有规范一些 SPL Exceptions，供开发者规范自己的错误异常架构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP（PHP_VERSION &amp;gt;= 7） 的 Error / Exception 的捕获与处理还是值得一说的&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Mycat实践-2：全局序列号</title>
    <link href="http://yoursite.com/2018/09/06/mysql-5/"/>
    <id>http://yoursite.com/2018/09/06/mysql-5/</id>
    <published>2018-09-06T12:31:38.000Z</published>
    <updated>2019-04-12T09:23:18.278Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mycat实践-1遇到的全局序列号问题"><a href="#Mycat实践-1遇到的全局序列号问题" class="headerlink" title="Mycat实践-1遇到的全局序列号问题"></a>Mycat实践-1遇到的全局序列号问题</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">在上一节的介绍中，我们遇到了一个insert无法插入的问题  </span><br><span class="line">我们思考一个问题，我们上一节在mysql上创建了3个分库，每个分库下每一个对应的表  </span><br><span class="line">CREATE TABLE `travelrecord` (  </span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  </span><br><span class="line">  `name` varchar(22) NOT NULL DEFAULT &apos;&apos;,  </span><br><span class="line">  `time` int(10) unsigned NOT NULL DEFAULT &apos;0&apos;,  </span><br><span class="line">  PRIMARY KEY (`id`)  </span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;  </span><br><span class="line">  </span><br><span class="line">这里的id是自增长，如果是在mycat的分布式下，肯定面临这一个id序列的增长问题。  </span><br><span class="line"></span><br><span class="line">如果我们各自在mysql端的三个库分别插入不同的数据，如：  </span><br><span class="line">use mycat-db1;  </span><br><span class="line">insert into travelrecord(name, time) values(&apos;test1&apos;, 0);  </span><br><span class="line">use mycat-db2;  </span><br><span class="line">insert into travelrecord(name, time) values(&apos;test1&apos;, 0);  </span><br><span class="line">use mycat-db3;  </span><br><span class="line">insert into travelrecord(name, time) values(&apos;test1&apos;, 0);  </span><br><span class="line"></span><br><span class="line">这里面临的每一个库下增长各自分离，所以可能不同db之间下的id可能会重复  </span><br><span class="line"></span><br><span class="line">mycat肯定要解决不同datahost下的datanode的结合后逻辑表下面的序列重复问题，所以插入就遇到了问题  </span><br><span class="line"></span><br><span class="line">接下去我们通过mycat的全局序列号解决插入的问题</span><br></pre></td></tr></table></figure><h3 id="Mycat-全局序列号"><a href="#Mycat-全局序列号" class="headerlink" title="Mycat 全局序列号"></a>Mycat 全局序列号</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在实现分库分表的情况下，数据库自增主键已无法保证自增主键的全局唯一。为此， MyCat 提供了全局sequence，并且提供了包含本地配置和数据库配置等多种实现方式</p><h4 id="全局序列的三种方式"><a href="#全局序列的三种方式" class="headerlink" title="全局序列的三种方式"></a>全局序列的三种方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 本地文件  </span><br><span class="line">缺点：在mycat重启后，配置文件中sequence会恢复到初始值，造成下次操作序列重复  </span><br><span class="line">优点：本地加载，读取速度较快  </span><br><span class="line"></span><br><span class="line">2. 数据库  </span><br><span class="line">优点：在mycat重启后，sequence值不会被初始化  </span><br><span class="line">缺点：如果存取sequence的数据库挂了，会遇到单点故障  </span><br><span class="line"></span><br><span class="line">3. 时间  </span><br><span class="line">优点：不存在上面两种方案因为mycat的重启导致id重复的现象  </span><br><span class="line">缺点：数据类型太长，建议采用bigint(最大取值18446744073709551615)  </span><br><span class="line"></span><br><span class="line">4. zookeeper  </span><br><span class="line">建议采用，zookeeper自身解决单点和序列问题</span><br></pre></td></tr></table></figure><h4 id="本地方式"><a href="#本地方式" class="headerlink" title="本地方式"></a>本地方式</h4><p>mycat conf/server.xml配置调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;sequnceHandlerType&quot;&gt;0&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>查看配置是否生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 重启mycat</span><br><span class="line"># 先停止 startup_nowrap.bat</span><br><span class="line">bin/startup_nowrap.bat</span><br><span class="line"></span><br><span class="line">我这边是通过navicat连接(command)</span><br><span class="line"># mysql -uroot -p123456 -p 9066</span><br><span class="line"></span><br><span class="line">show @@sysparam;</span><br><span class="line"></span><br><span class="line"># output: 输出了本地文件方式，表示配置成功</span><br><span class="line">...</span><br><span class="line">| sequnceHandlerType            | 本地文件方式  | 指定使用Mycat全局序列的类型。|</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 第一次尝试</span><br><span class="line">insert into travelrecord(name) values(&apos;20180802 13:32&apos;);</span><br><span class="line"># output: 提示错误了，提示了什么ID列没有提供</span><br><span class="line">[SQL]insert into travelrecord(name) values(&apos;20180802 13:32&apos;);</span><br><span class="line">[Err] 1064 - bad insert sql (sharding column:ID not provided,INSERT INTO travelrecord (name)</span><br><span class="line">VALUES (&apos;20180802 13:32&apos;)</span><br><span class="line"></span><br><span class="line"># 第二次尝试</span><br><span class="line">insert into travelrecord(id, name) values(next value for MYCATSEQ_GLOBAL, &apos;20180802 13:32&apos;);</span><br><span class="line"># output: 成功</span><br><span class="line">受影响的行: 1</span><br><span class="line">时间: 0.004s</span><br><span class="line"></span><br><span class="line">不过这样写起来很麻烦，而且会改变现有业务里的代码，因为平常的单机业务的代码大多是不会写id的，都是利用mysql的主键自增长</span><br></pre></td></tr></table></figure><p>next value for MYCATSEQ_XXX 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">是mycat用于分布式序列生成的的一种方式，在mycat里这个根据sequnceHandlerType的三种方式对应到不同的三个配置文件分别是：</span><br><span class="line">sequence_conf.properties -&gt; 本地</span><br><span class="line">sequence_db_conf.properties -&gt; mysql</span><br><span class="line">sequence_time_conf.properties -&gt; time</span><br><span class="line">sequence_distributed_conf.properties -&gt; zookeeper等分布式支持</span><br><span class="line"></span><br><span class="line">上个测试我们使用了next value for MYCATSEQ_GLOBAL</span><br><span class="line">打开sequence_conf.properties查看</span><br><span class="line"></span><br><span class="line">COMPANY.MAXID=2000</span><br><span class="line">GLOBAL.MAXID=20000</span><br><span class="line">COMPANY.HISIDS=</span><br><span class="line">CUSTOMER.MAXID=2000</span><br><span class="line">HOTNEWS.CURID=1000</span><br><span class="line">ORDER.MINID=1001</span><br><span class="line">CUSTOMER.HISIDS=</span><br><span class="line">HOTNEWS.MINID=1001</span><br><span class="line">TRAVELRECORD.MAXID=2000000</span><br><span class="line">GLOBAL.CURID=10003</span><br><span class="line">ORDER.MAXID=2000</span><br><span class="line">TRAVELRECORD.HISIDS=</span><br><span class="line">COMPANY.CURID=1000</span><br><span class="line">CUSTOMER.CURID=1000</span><br><span class="line">COMPANY.MINID=1001</span><br><span class="line">GLOBAL.MINID=10001</span><br><span class="line">HOTNEWS.MAXID=2000</span><br><span class="line">CUSTOMER.MINID=1001</span><br><span class="line">TRAVELRECORD.CURID=506</span><br><span class="line">GLOBAL.HISIDS=</span><br><span class="line">HOTNEWS.HISIDS=</span><br><span class="line">ORDER.CURID=1000</span><br><span class="line">TRAVELRECORD.MINID=5001</span><br><span class="line">ORDER.HISIDS=</span><br><span class="line"></span><br><span class="line"># 查看我们之前插入的数据：</span><br><span class="line">select * from travelrecord;</span><br><span class="line">...</span><br><span class="line">| 10002 | 20180802 13:32 |    0 |</span><br><span class="line">...</span><br><span class="line">我们看到id插入是10002，自增长来自GLOBAL.CURID</span><br></pre></td></tr></table></figure><p>自增长式插入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># schema.xml里的配置增加2个属性， mycat会根据表自动获取到sequence配置里的属性</span><br><span class="line"># &lt;table name=&quot;travelrecord&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; rule=&quot;auto-sharding-long&quot; /&gt;</span><br><span class="line"># mycat重启</span><br><span class="line"></span><br><span class="line">insert into travelrecord(name) values(&apos;20180802 13:49&apos;);</span><br><span class="line"># output: 成功</span><br><span class="line">受影响的行: 1</span><br><span class="line">时间: 0.004s</span><br><span class="line"></span><br><span class="line"># 查看我们之前插入的数据：</span><br><span class="line">select * from travelrecord;</span><br><span class="line">...</span><br><span class="line">|   507 | 20180802 13:49 |    0 |</span><br><span class="line">...</span><br><span class="line">我们看到id插入是507，自增长来自TRAVELRECORD.CURID</span><br></pre></td></tr></table></figure></p><h4 id="数据库方式"><a href="#数据库方式" class="headerlink" title="数据库方式"></a>数据库方式</h4><p>mycat conf/server.xml配置调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;sequnceHandlerType&quot;&gt;1&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>查看配置是否生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同本地方式</span><br><span class="line"></span><br><span class="line">| sequnceHandlerType            | 数据库方式    | 指定使用Mycat全局序列的类型。|</span><br></pre></td></tr></table></figure><p>sql命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># 序列表</span><br><span class="line">CREATE TABLE `mycat_sequence` (</span><br><span class="line">  `name` varchar(50) NOT NULL,</span><br><span class="line">  `current_value` int(11) NOT NULL,</span><br><span class="line">  `increment` int(11) NOT NULL DEFAULT &apos;1&apos;,</span><br><span class="line">  PRIMARY KEY (`name`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"># mycat_seq_currval函数</span><br><span class="line">CREATE FUNCTION `mycat_seq_currval`(seq_name VARCHAR(50)) RETURNS varchar(64) CHARSET utf8 DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE retval VARCHAR (64);</span><br><span class="line"></span><br><span class="line">SET retval = &quot;-999999999,null&quot;;</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">    CONCAT(</span><br><span class="line">        CAST(current_value AS CHAR),</span><br><span class="line">        &quot;,&quot;,</span><br><span class="line">        CAST(increment AS CHAR)</span><br><span class="line">    ) INTO retval</span><br><span class="line">FROM</span><br><span class="line">    MYCAT_SEQUENCE</span><br><span class="line">WHERE</span><br><span class="line">    NAME = seq_name;</span><br><span class="line"></span><br><span class="line">RETURN retval;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># mycat_seq_nextval函数</span><br><span class="line">CREATE FUNCTION `mycat_seq_nextval`(seq_name VARCHAR(50)) RETURNS varchar(64) CHARSET utf8 DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">    UPDATE MYCAT_SEQUENCE</span><br><span class="line">        SET current_value = current_value + increment</span><br><span class="line">    WHERE</span><br><span class="line">        NAME = seq_name;</span><br><span class="line"></span><br><span class="line">RETURN mycat_seq_currval (seq_name);</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># mycat_seq_setval函数</span><br><span class="line">CREATE FUNCTION `mycat_seq_setval`(</span><br><span class="line">    seq_name VARCHAR (50), VALUE INTEGER</span><br><span class="line">) RETURNS varchar(64) CHARSET utf8 DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">    UPDATE MYCAT_SEQUENCE</span><br><span class="line">        SET current_value = VALUE</span><br><span class="line">    WHERE</span><br><span class="line">        NAME = seq_name;</span><br><span class="line">RETURN mycat_seq_currval (seq_name);</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># test</span><br><span class="line">select mycat_seq_currval(&apos;TRAVELRECORD&apos;);</span><br><span class="line"># output: 800,1</span><br></pre></td></tr></table></figure><p>插入一条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `mycat-db1`.`mycat_sequence` (`name`, `current_value`, `increment`) VALUES (&apos;TRAVELRECORD&apos;, &apos;800&apos;, &apos;1&apos;);</span><br></pre></td></tr></table></figure><p>插入数据测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">insert into travelrecord(name) values(&apos;20180802 14:18&apos;);</span><br><span class="line"># output: 成功</span><br><span class="line">受影响的行: 1</span><br><span class="line">时间: 0.004s</span><br><span class="line"></span><br><span class="line"># 查看我们之前插入的数据：</span><br><span class="line">select * from travelrecord;</span><br><span class="line">...</span><br><span class="line">|   801 | 20180802 14:18 |    0 |</span><br><span class="line">...</span><br><span class="line">我们看到id插入是801，自增长来自数据表，查看数据库表, 并自动修改表的当前记录+1（我们的increment=1）</span><br><span class="line"></span><br><span class="line"># 切换到真实的mycat-db1</span><br><span class="line">select * from mycat_sequence;</span><br><span class="line">| TRAVELRECORD |           801 |         1 |</span><br></pre></td></tr></table></figure><h4 id="时间方式"><a href="#时间方式" class="headerlink" title="时间方式"></a>时间方式</h4><p>mycat conf/server.xml配置调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;sequnceHandlerType&quot;&gt;2&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>查看配置是否生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同上不重复了</span><br><span class="line"></span><br><span class="line">| sequnceHandlerType            | 本地文件方式  | 指定使用Mycat全局序列的类型。 |</span><br><span class="line"></span><br><span class="line"># 这里应该是mycat的显示bug，配置成了时间戳序列方式了，显示的还是本地文件方式</span><br></pre></td></tr></table></figure><p>插入等测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">select next value for MYCATSEQ_GLOBAL;</span><br><span class="line"># 1024911601620357120</span><br><span class="line"></span><br><span class="line">select next value for MYCATSEQ_GLOBAL;</span><br><span class="line"># 1024911649208930304</span><br><span class="line"></span><br><span class="line">insert into travelrecord(name) values(&apos;20180808 14:56&apos;)</span><br><span class="line">#output: </span><br><span class="line">[Err] 1064 - can&apos;t find any valid datanode :TRAVELRECORD -&gt; ID -&gt; 1024911922555916288</span><br><span class="line"># 上面的出错，是因为我们的表插入的路由方式是rule=&quot;auto-sharding-long&quot;，找不到这么多的序列对应的datanode</span><br><span class="line"># 调整 rule=&quot;mod-long&quot;，并修改三个真实分库的id未bigint(20) 并重启mycat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into travelrecord(name) values(&apos;20180808 15:01&apos;);</span><br><span class="line"># 受影响的行: 1</span><br><span class="line"># 时间: 0.048s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from travelrecord;</span><br><span class="line">...</span><br><span class="line">| 1024910441362624512 | 20180802 14:51 |    0 |</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="分布式方式（zookeeper）"><a href="#分布式方式（zookeeper）" class="headerlink" title="分布式方式（zookeeper）"></a>分布式方式（zookeeper）</h4><p>mycat conf/server.xml配置调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;sequnceHandlerType&quot;&gt;3&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>查看配置是否生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同上不重复了</span><br><span class="line"></span><br><span class="line">| sequnceHandlerType            | 本地文件方式  | 指定使用Mycat全局序列的类型。 |</span><br><span class="line"></span><br><span class="line"># 这里应该是mycat的显示bug，配置成了分布式方式了，显示的还是本地文件方式</span><br></pre></td></tr></table></figure><p>zookpeeper安装部分太长省略</p><p>myid.properties:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">loadZk=true</span><br><span class="line">zkURL=127.0.0.1:2181</span><br><span class="line">clusterId=mycat-cluster-1</span><br><span class="line">myid=mycat_fz_01</span><br><span class="line">clusterNodes=mycat_fz_01,mycat_fz_02,mycat_fz_04</span><br><span class="line">#server  booster  ;   booster install on db same server,will reset all minCon to 1</span><br><span class="line">type=server</span><br><span class="line">boosterDataHosts=localhost1</span><br></pre></td></tr></table></figure><p>初始化mycat zk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/init_zk_data.cmd</span><br></pre></td></tr></table></figure><p>插入等测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select next value for MYCATSEQ_GLOBAL;</span><br><span class="line"># 5328679401562341409</span><br><span class="line">select next value for MYCATSEQ_GLOBAL;</span><br><span class="line"># 5328680350783668258</span><br><span class="line"></span><br><span class="line">insert into travelrecord(name) values(&apos;20180808 15:58&apos;);</span><br><span class="line"># 受影响的行: 1</span><br><span class="line"># 时间: 0.048s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from travelrecord;</span><br><span class="line">...</span><br><span class="line">| 5328681411405709347 | 20180808 15:58 |    0 |</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>总结</p><p>我们在mycat分布式的环境下，建议全局序列id的顺序: zookeeper &gt; mysql &gt; timestamp(SnowFlake) &gt; localfile</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mycat实践-1遇到的全局序列号问题&quot;&gt;&lt;a href=&quot;#Mycat实践-1遇到的全局序列号问题&quot; class=&quot;headerlink&quot; title=&quot;Mycat实践-1遇到的全局序列号问题&quot;&gt;&lt;/a&gt;Mycat实践-1遇到的全局序列号问题&lt;/h3&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="http://yoursite.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Mycat实践-1</title>
    <link href="http://yoursite.com/2018/07/30/mysql-4/"/>
    <id>http://yoursite.com/2018/07/30/mysql-4/</id>
    <published>2018-07-30T15:31:38.000Z</published>
    <updated>2019-04-12T09:23:18.165Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mycat简介"><a href="#Mycat简介" class="headerlink" title="Mycat简介"></a>Mycat简介</h4><ul><li>一个彻底开源的，面向企业应用开发的大数据库集群</li><li>支持事务、ACID、可以替代MySQL的加强版数据库<a id="more"></a></li><li>一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群</li><li>一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server</li><li>结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品</li><li>一个新颖的数据库中间件产品</li></ul><h4 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h4><ul><li>支持SQL92标准</li><li>支持MySQL、Oracle、DB2、SQL Server、PostgreSQL等DB的常见SQL语法</li><li>遵守Mysql原生协议，跨语言，跨平台，跨数据库的通用中间件代理。</li><li>基于心跳的自动故障切换，支持读写分离，支持MySQL主从，以及galera cluster集群。</li><li>支持Galera for MySQL集群，Percona Cluster或者MariaDB cluster</li><li>基于Nio实现，有效管理线程，解决高并发问题。</li><li>支持数据的多片自动路由与聚合，支持sum,count,max等常用的聚合函数,支持跨库分页。</li><li>支持单库内部任意join，支持跨库2表join，甚至基于caltlet的多表join。</li><li>支持通过全局表，ER关系的分片策略，实现了高效的多表join查询。</li><li>支持多租户方案。</li><li>支持分布式事务（弱xa）。</li><li>支持XA分布式事务（1.6.5）。</li><li>支持全局序列号，解决分布式下的主键生成问题。</li><li>分片规则丰富，插件化开发，易于扩展。</li><li>强大的web，命令行监控。</li><li>支持前端作为MySQL通用代理，后端JDBC方式支持Oracle、DB2、SQL Server 、 mongodb 、巨杉。</li><li>支持密码加密</li><li>支持服务降级</li><li>支持IP白名单</li><li>支持SQL黑名单、sql注入攻击拦截</li><li>支持prepare预编译指令（1.6）</li><li>支持非堆内存(Direct Memory)聚合计算（1.6）</li><li>支持PostgreSQL的native协议（1.6）</li><li>支持mysql和oracle存储过程，out参数、多结果集返回（1.6）</li><li>支持zookeeper协调主从切换、zk序列、配置zk化（1.6）</li><li>支持库内分表（1.6）</li><li>集群基于ZooKeeper管理，在线升级，扩容，智能优化，大数据处理（2.0开发版）。</li></ul><h4 id="目前最新版本"><a href="#目前最新版本" class="headerlink" title="目前最新版本"></a>目前最新版本</h4><blockquote><p><a href="http://dl.mycat.io/1.6-RELEASE/" target="_blank" rel="noopener">http://dl.mycat.io/1.6-RELEASE/</a></p></blockquote><h4 id="长期规划"><a href="#长期规划" class="headerlink" title="长期规划"></a>长期规划</h4><ul><li>完全实现分布式事务，完全的支持分布式。</li><li>通过Mycat web（eye）完成可视化配置，及智能监控，自动运维。</li><li>通过mysql 本地节点，完整的解决数据扩容难度，实现自动扩容机制，解决扩容难点。</li><li>支持基于zookeeper的主从切换及Mycat集群化管理。</li><li>通过Mycat Balance 替代第三方的Haproxy，LVS等第三方高可用，完整的兼容Mycat集群节点的动态上下线。</li><li>接入Spark等第三方工具，解决数据分析及大数据聚合的业务场景。</li><li>通过Mycat智能优化，分析分片热点，提供合理的分片建议，索引建议，及数据切分实时业务建议。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Mycat 是一个数据库的中间件，支持各种常规的MySQL、Oracle、DB2、SQL Server、PostgreSQL的支持，支持分库分表等分布式下的业务架构，让前端开发可以几乎透明.</p><h3 id="服务端简单初始部署"><a href="#服务端简单初始部署" class="headerlink" title="服务端简单初始部署"></a>服务端简单初始部署</h3><p>本案例我们将会初始一个同主机下三个分库(mycat-db1,mycat-db2,mycat-db3)通过mycat中间件，前端连接mycat操作</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><blockquote><p># win下部署、正式环境建议linux部署<br>JDK<br>Mysql<br>mycat1.6 win 源码</p></blockquote><h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># wget http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-windows-x64.exe  </span><br><span class="line">一路next安装  </span><br><span class="line">#配置 JDK 环境  </span><br><span class="line">JAVA_HOME：C:\Program Files\Java\jdk1.8.0_162  </span><br><span class="line">CLASSPATH：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;  </span><br><span class="line">PATH：;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;  </span><br><span class="line"># DEBUG  </span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p>这部分安装就不说了<br>我这边安装的是mysql5.6版本  </p><h4 id="初始化三个分库"><a href="#初始化三个分库" class="headerlink" title="初始化三个分库"></a>初始化三个分库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 此操作在当前机的mysql上操作（不再mycat）</span><br><span class="line"># mysql -uroot -p</span><br><span class="line">CREATE DATABASE IF NOT EXISTS mycat-db1 DEFAULT CHARSET utf8mb4 COLLATE utf8mb4_general_ci;</span><br><span class="line">CREATE DATABASE IF NOT EXISTS mycat-db2 DEFAULT CHARSET utf8mb4 COLLATE utf8mb4_general_ci;</span><br><span class="line">CREATE DATABASE IF NOT EXISTS mycat-db3 DEFAULT CHARSET utf8mb4 COLLATE utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"># 三个分库各自创建表travelrecord</span><br><span class="line">CREATE TABLE `travelrecord` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(22) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `time` int(10) unsigned NOT NULL DEFAULT &apos;0&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br><span class="line"># 模拟数据</span><br><span class="line">INSERT INTO `mycat-db1`.`travelrecord` (`name`, `time`) VALUES (&apos;qkl&apos;, &apos;0&apos;);</span><br><span class="line">INSERT INTO `mycat-db1`.`travelrecord` (`name`, `time`) VALUES (&apos;andy&apos;, &apos;0&apos;);</span><br><span class="line">INSERT INTO `mycat-db2`.`travelrecord` (`name`, `time`) VALUES (&apos;zgq&apos;, &apos;0&apos;);</span><br><span class="line">INSERT INTO `mycat-db3`.`travelrecord` (`name`, `time`) VALUES (&apos;pcb&apos;, &apos;0&apos;);</span><br></pre></td></tr></table></figure><h4 id="mycat-conf-server-xml配置"><a href="#mycat-conf-server-xml配置" class="headerlink" title="mycat conf/server.xml配置"></a>mycat conf/server.xml配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:server SYSTEM &quot;server.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:server xmlns:mycat=&quot;http://io.mycat/&quot;&gt;</span><br><span class="line">    &lt;system&gt;</span><br><span class="line">    &lt;property name=&quot;useSqlStat&quot;&gt;0&lt;/property&gt;  &lt;!-- 1为开启实时统计、0为关闭 --&gt;</span><br><span class="line">    &lt;property name=&quot;useGlobleTableCheck&quot;&gt;0&lt;/property&gt;  &lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=&quot;sequnceHandlerType&quot;&gt;2&lt;/property&gt;</span><br><span class="line">      &lt;!--  &lt;property name=&quot;useCompression&quot;&gt;1&lt;/property&gt;--&gt; &lt;!--1为开启mysql压缩协议--&gt;</span><br><span class="line">        &lt;!--  &lt;property name=&quot;fakeMySQLVersion&quot;&gt;5.6.20&lt;/property&gt;--&gt; &lt;!--设置模拟的MySQL版本号--&gt;</span><br><span class="line">    &lt;!-- &lt;property name=&quot;processorBufferChunk&quot;&gt;40960&lt;/property&gt; --&gt;</span><br><span class="line">    &lt;!-- </span><br><span class="line">    &lt;property name=&quot;processors&quot;&gt;1&lt;/property&gt; </span><br><span class="line">    &lt;property name=&quot;processorExecutor&quot;&gt;32&lt;/property&gt; </span><br><span class="line">     --&gt;</span><br><span class="line">        &lt;!--默认为type 0: DirectByteBufferPool | type 1 ByteBufferArena--&gt;</span><br><span class="line">        &lt;property name=&quot;processorBufferPoolType&quot;&gt;0&lt;/property&gt;</span><br><span class="line">        &lt;!--默认是65535 64K 用于sql解析时最大文本长度 --&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;maxStringLiteralLength&quot;&gt;65535&lt;/property&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;sequnceHandlerType&quot;&gt;0&lt;/property&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;backSocketNoDelay&quot;&gt;1&lt;/property&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;frontSocketNoDelay&quot;&gt;1&lt;/property&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;property name=&quot;processorExecutor&quot;&gt;16&lt;/property&gt;--&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            &lt;property name=&quot;serverPort&quot;&gt;8066&lt;/property&gt; &lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt; </span><br><span class="line">            &lt;property name=&quot;idleTimeout&quot;&gt;300000&lt;/property&gt; &lt;property name=&quot;bindIp&quot;&gt;0.0.0.0&lt;/property&gt; </span><br><span class="line">            &lt;property name=&quot;frontWriteQueueSize&quot;&gt;4096&lt;/property&gt; &lt;property name=&quot;processors&quot;&gt;32&lt;/property&gt; --&gt;</span><br><span class="line">        &lt;!--分布式事务开关，0为不过滤分布式事务，1为过滤分布式事务（如果分布式事务内只涉及全局表，则不过滤），2为不过滤分布式事务,但是记录分布式事务日志--&gt;</span><br><span class="line">        &lt;property name=&quot;handleDistributedTransactions&quot;&gt;0&lt;/property&gt;</span><br><span class="line">        </span><br><span class="line">            &lt;!--</span><br><span class="line">            off heap for merge/order/group/limit      1开启   0关闭</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=&quot;useOffHeapForMerge&quot;&gt;1&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--</span><br><span class="line">            单位为m</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=&quot;memoryPageSize&quot;&gt;1m&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--</span><br><span class="line">            单位为k</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=&quot;spillsFileBufferSize&quot;&gt;1k&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=&quot;useStreamOutput&quot;&gt;0&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--</span><br><span class="line">            单位为m</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=&quot;systemReserveMemorySize&quot;&gt;384m&lt;/property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!--是否采用zookeeper协调切换  --&gt;</span><br><span class="line">        &lt;property name=&quot;useZKSwitch&quot;&gt;true&lt;/property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/system&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这部分是我们通过客户端连接需要设置的帐号密码 --&gt;</span><br><span class="line">    &lt;user name=&quot;root&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- 表级 DML 权限设置 --&gt;</span><br><span class="line">        &lt;!--         </span><br><span class="line">        &lt;privileges check=&quot;false&quot;&gt;</span><br><span class="line">            &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;</span><br><span class="line">                &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;</span><br><span class="line">                &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;</span><br><span class="line">            &lt;/schema&gt;</span><br><span class="line">        &lt;/privileges&gt;        </span><br><span class="line">         --&gt;</span><br><span class="line">    &lt;/user&gt;</span><br><span class="line"></span><br><span class="line">    &lt;user name=&quot;user&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot;&gt;user&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;</span><br><span class="line">    &lt;/user&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mycat:server&gt;</span><br></pre></td></tr></table></figure><h4 id="mycat-conf-schema-xml配置"><a href="#mycat-conf-schema-xml配置" class="headerlink" title="mycat conf/schema.xml配置"></a>mycat conf/schema.xml配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot;</span><br><span class="line">              writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;</span><br><span class="line">        &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</span><br><span class="line">        &lt;!-- 真实对应的读写的数据库 --&gt;</span><br><span class="line">        &lt;writeHost host=&quot;hostM1&quot; url=&quot;localhost:3306&quot; user=&quot;root&quot;</span><br><span class="line">                   password=&quot;root&quot;&gt;</span><br><span class="line">        &lt;/writeHost&gt;</span><br><span class="line">    &lt;/dataHost&gt;</span><br><span class="line"></span><br><span class="line">    &lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt;</span><br><span class="line">        &lt;table name=&quot;travelrecord&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;auto-sharding-long&quot; /&gt;</span><br><span class="line">    &lt;/schema&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost1&quot; database=&quot;mycat-db1&quot; /&gt;</span><br><span class="line">    &lt;dataNode name=&quot;dn2&quot; dataHost=&quot;localhost1&quot; database=&quot;mycat-db2&quot; /&gt;</span><br><span class="line">    &lt;dataNode name=&quot;dn3&quot; dataHost=&quot;localhost1&quot; database=&quot;mycat-db3&quot; /&gt;</span><br><span class="line">&lt;/mycat:schema&gt;</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/startup_nowrap.bat</span><br><span class="line"># 启动成功最后显示</span><br><span class="line"># MyCAT Server startup successfully. see logs in logs/mycat.log</span><br></pre></td></tr></table></figure><h3 id="客户端连接测试"><a href="#客户端连接测试" class="headerlink" title="客户端连接测试"></a>客户端连接测试</h3><h4 id="客户端连接管理"><a href="#客户端连接管理" class="headerlink" title="客户端连接管理"></a>客户端连接管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我这边是通过navicat连接</span><br><span class="line"># mysql -uroot -p123456 -p 9066</span><br><span class="line">连接帐号密码：root/123456 -&gt; server.xml配置可得</span><br><span class="line"></span><br><span class="line">show @@help;</span><br><span class="line">show @@sysparam;</span><br></pre></td></tr></table></figure><h4 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我这边是通过navicat连接</span><br><span class="line"># mysql -uroot -p123456 -p 8066</span><br><span class="line">连接帐号密码：root/123456 -&gt; server.xml配置可得</span><br></pre></td></tr></table></figure><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">use TESTDB;</span><br><span class="line"></span><br><span class="line"># select</span><br><span class="line">select * from travelrecord;</span><br><span class="line"></span><br><span class="line"># output:</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | name | time |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  1 | qkl  |    0 |</span><br><span class="line">|  2 | andy |    0 |</span><br><span class="line">|  1 | pcb  |    0 |</span><br><span class="line">|  1 | zgq  |    0 |</span><br><span class="line">+----+------+------+</span><br><span class="line">4 rows in set</span><br><span class="line"></span><br><span class="line"># update</span><br><span class="line">update travelrecord set name=&apos;andy2&apos; where id = 2;</span><br><span class="line"></span><br><span class="line"># insert</span><br><span class="line">insert into travelrecord(name, time) values(&apos;tony&apos;, 0);</span><br><span class="line"># 出错</span><br><span class="line">#[Err] 1064 - bad insert sql (sharding column:ID not provided,INSERT INTO travelrecord (name, time)</span><br><span class="line">VALUES (&apos;test&apos;, 0)</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>我们利用mycat做了一个单点mysql的多分库下支持简单查询的实践，可以正常查询不过在我们进行插入的时间遇到了问题</p><p>下一节我们将利用Mycat的全局序列号解决利用mycat的插入问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Mycat简介&quot;&gt;&lt;a href=&quot;#Mycat简介&quot; class=&quot;headerlink&quot; title=&quot;Mycat简介&quot;&gt;&lt;/a&gt;Mycat简介&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;一个彻底开源的，面向企业应用开发的大数据库集群&lt;/li&gt;
&lt;li&gt;支持事务、ACID、可以替代MySQL的加强版数据库&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="http://yoursite.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>PHP下kafka的实践</title>
    <link href="http://yoursite.com/2018/07/27/php-kafka/"/>
    <id>http://yoursite.com/2018/07/27/php-kafka/</id>
    <published>2018-07-27T05:56:29.000Z</published>
    <updated>2019-04-15T01:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Kafka 是一种高吞吐量的分布式发布订阅消息系统<br><a id="more"></a></p><h4 id="kafka角色必知"><a href="#kafka角色必知" class="headerlink" title="kafka角色必知"></a>kafka角色必知</h4><ul><li>producer：生产者。</li><li>consumer：消费者。</li><li>topic: 消息以topic为类别记录,Kafka将消息种子(Feed)分类, 每一类的消息称之为一个主题(Topic)。</li><li>broker：以集群的方式运行,可以由一个或多个服务组成，每个服务叫做一个broker;消费者可以订阅一个或多个主题(topic), 并从Broker拉数据,从而消费这些已发布的消息。</li></ul><h4 id="经典模型"><a href="#经典模型" class="headerlink" title="经典模型"></a>经典模型</h4><ol><li>一个主题下的分区不能小于消费者数量，即一个主题下消费者数量不能大于分区属，大了就浪费了空闲了</li><li>一个主题下的一个分区可以同时被不同消费组其中某一个消费者消费</li><li>一个主题下的一个分区只能被同一个消费组的一个消费者消费</li></ol><p><img src="/2018/07/27/php-kafka/4.png" alt="p4"></p><h4 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h4><p>request.required.acks</p><blockquote><p>Kafka producer的ack有3种机制，初始化producer时的producerconfig可以通过配置request.required.acks不同的值来实现。<br>0：这意味着生产者producer不等待来自broker同步完成的确认继续发送下一条（批）消息。此选项提供最低的延迟但最弱的耐久性保证（当服务器发生故障时某些数据会丢失，如leader已死，但producer并不知情，发出去的信息broker就收不到）。<br>1：这意味着producer在leader已成功收到的数据并得到确认后发送下一条message。此选项提供了更好的耐久性为客户等待服务器确认请求成功（被写入死亡leader但尚未复制将失去了唯一的消息）。<br>-1：这意味着producer在follower副本确认接收到数据后才算一次发送完成。<br>此选项提供最好的耐久性，我们保证没有信息将丢失，只要至少一个同步副本保持存活。<br>三种机制，性能依次递减 (producer吞吐量降低)，数据健壮性则依次递增。  </p></blockquote><p>auto.offset.reset</p><blockquote><p>earliest：自动将偏移重置为最早的偏移量<br>latest：自动将偏移量重置为最新的偏移量（默认）<br>none：如果consumer group没有发现先前的偏移量，则向consumer抛出异常。<br>其他的参数：向consumer抛出异常（无效参数）  </p></blockquote><h3 id="kafka安装和简单测试"><a href="#kafka安装和简单测试" class="headerlink" title="kafka安装和简单测试"></a>kafka安装和简单测试</h3><h4 id="安装kafka（不需要安装，解包即可）"><a href="#安装kafka（不需要安装，解包即可）" class="headerlink" title="安装kafka（不需要安装，解包即可）"></a>安装kafka（不需要安装，解包即可）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 官方下载地址：http://kafka.apache.org/downloads</span><br><span class="line"># wget https://www.apache.org/dyn/closer.cgi?path=/kafka/1.1.1/kafka_2.12-1.1.1.tgz</span><br><span class="line">tar -xzf kafka_2.12-1.1.1.tgz</span><br><span class="line">cd kafka_2.12-1.1.0</span><br></pre></td></tr></table></figure><h4 id="启动kafka-server"><a href="#启动kafka-server" class="headerlink" title="启动kafka server"></a>启动kafka server</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 需先启动zookeeper</span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure><h4 id="启动kafka客户端测试"><a href="#启动kafka客户端测试" class="headerlink" title="启动kafka客户端测试"></a>启动kafka客户端测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个话题，test话题2个分区</span><br><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 2 --topic test</span><br><span class="line">Created topic &quot;test&quot;.</span><br><span class="line"></span><br><span class="line"># 显示所有话题</span><br><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line"># 显示话题信息</span><br><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test</span><br><span class="line">Topic:test    PartitionCount:2    ReplicationFactor:1    Configs:</span><br><span class="line">    Topic: test    Partition: 0    Leader: 0    Replicas: 0    Isr: 0</span><br><span class="line">    Topic: test    Partition: 1    Leader: 0    Replicas: 0    Isr: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启动一个生产者（输入消息）</span><br><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line">[等待输入自己的内容 出现&gt;输入即可]</span><br><span class="line">&gt;i am a new msg !</span><br><span class="line">&gt;i am a good msg ?</span><br><span class="line"></span><br><span class="line"># 启动一个生产者（等待消息） </span><br><span class="line"># 注意这里的--from-beginning，每次都会从头开始读取，你可以尝试去掉和不去掉看下效果</span><br><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br><span class="line">[等待消息]</span><br><span class="line">i am a new msg !</span><br><span class="line">i am a good msg ?</span><br></pre></td></tr></table></figure><h4 id="安装kafka的php扩展"><a href="#安装kafka的php扩展" class="headerlink" title="安装kafka的php扩展"></a>安装kafka的php扩展</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/arnaud-lb/php-rdkafka.git</span><br><span class="line">cd php-rdkafka</span><br><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line">make all -j 5</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">vim [phppath]/php.ini</span><br><span class="line">extension=rdkafka.so</span><br></pre></td></tr></table></figure><h3 id="php代码实践"><a href="#php代码实践" class="headerlink" title="php代码实践"></a>php代码实践</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$conf = new RdKafka\Conf();</span><br><span class="line">$conf-&gt;setDrMsgCb(function ($kafka, $message) &#123;</span><br><span class="line">    file_put_contents(&quot;./dr_cb.log&quot;, var_export($message, true).PHP_EOL, FILE_APPEND);</span><br><span class="line">&#125;);</span><br><span class="line">$conf-&gt;setErrorCb(function ($kafka, $err, $reason) &#123;</span><br><span class="line">    file_put_contents(&quot;./err_cb.log&quot;, sprintf(&quot;Kafka error: %s (reason: %s)&quot;, rd_kafka_err2str($err), $reason).PHP_EOL, FILE_APPEND);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$rk = new RdKafka\Producer($conf);</span><br><span class="line">$rk-&gt;setLogLevel(LOG_DEBUG);</span><br><span class="line">$rk-&gt;addBrokers(&quot;127.0.0.1&quot;);</span><br><span class="line"></span><br><span class="line">$cf = new RdKafka\TopicConf();</span><br><span class="line">$cf-&gt;set(&apos;request.required.acks&apos;, 0);</span><br><span class="line">$topic = $rk-&gt;newTopic(&quot;test&quot;, $cf);</span><br><span class="line"></span><br><span class="line">$option = &apos;qkl&apos;;</span><br><span class="line">for ($i = 0; $i &lt; 20; $i++) &#123;</span><br><span class="line">    //RD_KAFKA_PARTITION_UA自动选择分区</span><br><span class="line">    //$option可选</span><br><span class="line">    $topic-&gt;produce(RD_KAFKA_PARTITION_UA, 0, &quot;qkl . $i&quot;, $option);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$len = $rk-&gt;getOutQLen();</span><br><span class="line">while ($len &gt; 0) &#123;</span><br><span class="line">    $len = $rk-&gt;getOutQLen();</span><br><span class="line">    var_dump($len);</span><br><span class="line">    $rk-&gt;poll(50);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行生产者"><a href="#运行生产者" class="headerlink" title="运行生产者"></a>运行生产者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">php producer.php</span><br><span class="line"># output</span><br><span class="line"></span><br><span class="line">int(20)</span><br><span class="line">int(20)</span><br><span class="line">int(20)</span><br><span class="line">int(20)</span><br><span class="line">int(0)</span><br><span class="line"></span><br><span class="line"># 你可以查看你刚才上面启动的消费者shell应该会输出消息</span><br><span class="line">qkl . 0</span><br><span class="line">qkl . 1</span><br><span class="line">qkl . 2</span><br><span class="line">qkl . 3</span><br><span class="line">qkl . 4</span><br><span class="line">qkl . 5</span><br><span class="line">qkl . 6</span><br><span class="line">qkl . 7</span><br><span class="line">qkl . 8</span><br><span class="line">qkl . 9</span><br><span class="line">qkl . 10</span><br><span class="line">qkl . 11</span><br><span class="line">qkl . 12</span><br><span class="line">qkl . 13</span><br><span class="line">qkl . 14</span><br><span class="line">qkl . 15</span><br><span class="line">qkl . 16</span><br><span class="line">qkl . 17</span><br><span class="line">qkl . 18</span><br><span class="line">qkl . 19</span><br></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$conf = new RdKafka\Conf();</span><br><span class="line">$conf-&gt;setDrMsgCb(function ($kafka, $message) &#123;</span><br><span class="line">    file_put_contents(&quot;./c_dr_cb.log&quot;, var_export($message, true), FILE_APPEND);</span><br><span class="line">&#125;);</span><br><span class="line">$conf-&gt;setErrorCb(function ($kafka, $err, $reason) &#123;</span><br><span class="line">    file_put_contents(&quot;./err_cb.log&quot;, sprintf(&quot;Kafka error: %s (reason: %s)&quot;, rd_kafka_err2str($err), $reason).PHP_EOL, FILE_APPEND);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//设置消费组</span><br><span class="line">$conf-&gt;set(&apos;group.id&apos;, &apos;myConsumerGroup&apos;);</span><br><span class="line"></span><br><span class="line">$rk = new RdKafka\Consumer($conf);</span><br><span class="line">$rk-&gt;addBrokers(&quot;127.0.0.1&quot;);</span><br><span class="line"></span><br><span class="line">$topicConf = new RdKafka\TopicConf();</span><br><span class="line">$topicConf-&gt;set(&apos;request.required.acks&apos;, 1);</span><br><span class="line">//在interval.ms的时间内自动提交确认、建议不要启动</span><br><span class="line">//$topicConf-&gt;set(&apos;auto.commit.enable&apos;, 1);</span><br><span class="line">$topicConf-&gt;set(&apos;auto.commit.enable&apos;, 0);</span><br><span class="line">$topicConf-&gt;set(&apos;auto.commit.interval.ms&apos;, 100);</span><br><span class="line"></span><br><span class="line">// 设置offset的存储为file</span><br><span class="line">//$topicConf-&gt;set(&apos;offset.store.method&apos;, &apos;file&apos;);</span><br><span class="line">// 设置offset的存储为broker</span><br><span class="line"> $topicConf-&gt;set(&apos;offset.store.method&apos;, &apos;broker&apos;);</span><br><span class="line">//$topicConf-&gt;set(&apos;offset.store.path&apos;, __DIR__);</span><br><span class="line"></span><br><span class="line">//smallest：简单理解为从头开始消费，其实等价于上面的 earliest</span><br><span class="line">//largest：简单理解为从最新的开始消费，其实等价于上面的 latest</span><br><span class="line">//$topicConf-&gt;set(&apos;auto.offset.reset&apos;, &apos;smallest&apos;);</span><br><span class="line"></span><br><span class="line">$topic = $rk-&gt;newTopic(&quot;test&quot;, $topicConf);</span><br><span class="line"></span><br><span class="line">// 参数1消费分区0</span><br><span class="line">// RD_KAFKA_OFFSET_BEGINNING 重头开始消费</span><br><span class="line">// RD_KAFKA_OFFSET_STORED 最后一条消费的offset记录开始消费</span><br><span class="line">// RD_KAFKA_OFFSET_END 最后一条消费</span><br><span class="line">$topic-&gt;consumeStart(0, RD_KAFKA_OFFSET_BEGINNING);</span><br><span class="line">//$topic-&gt;consumeStart(0, RD_KAFKA_OFFSET_END); //</span><br><span class="line">//$topic-&gt;consumeStart(0, RD_KAFKA_OFFSET_STORED);</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">    //参数1表示消费分区，这里是分区0</span><br><span class="line">    //参数2表示同步阻塞多久</span><br><span class="line">    $message = $topic-&gt;consume(0, 12 * 1000);</span><br><span class="line">    switch ($message-&gt;err) &#123;</span><br><span class="line">        case RD_KAFKA_RESP_ERR_NO_ERROR:</span><br><span class="line">            var_dump($message);</span><br><span class="line">            break;</span><br><span class="line">        case RD_KAFKA_RESP_ERR__PARTITION_EOF:</span><br><span class="line">            echo &quot;No more messages; will wait for more\n&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case RD_KAFKA_RESP_ERR__TIMED_OUT:</span><br><span class="line">            echo &quot;Timed out\n&quot;;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new \Exception($message-&gt;errstr(), $message-&gt;err);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查看服务器元数据（topic-partition-broker）"><a href="#查看服务器元数据（topic-partition-broker）" class="headerlink" title="查看服务器元数据（topic/partition/broker）"></a>查看服务器元数据（topic/partition/broker）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">echo count($topics);</span><br><span class="line">echo &quot;--&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foreach ($topics as $topic) &#123;</span><br><span class="line"></span><br><span class="line">    $topicName = $topic-&gt;getTopic();</span><br><span class="line">    if ($topicName == &quot;__consumer_offsets&quot;) &#123;</span><br><span class="line">        continue ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $partitions = $topic-&gt;getPartitions();</span><br><span class="line">    foreach ($partitions as $partition) &#123;</span><br><span class="line">//        $rf = new ReflectionClass(get_class($partition));</span><br><span class="line">//        foreach ($rf-&gt;getMethods() as $f) &#123;</span><br><span class="line">//            var_dump($f);</span><br><span class="line">//        &#125;</span><br><span class="line">//        die();</span><br><span class="line">        $topPartition = new RdKafka\TopicPartition($topicName, $partition-&gt;getId());</span><br><span class="line">        echo  &quot;当前的话题：&quot; . ($topPartition-&gt;getTopic()) . &quot; - &quot; . $partition-&gt;getId() . &quot; - &quot;;</span><br><span class="line">        echo  &quot;offset：&quot; . ($topPartition-&gt;getOffset()) . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;kafka&quot;&gt;&lt;a href=&quot;#kafka&quot; class=&quot;headerlink&quot; title=&quot;kafka&quot;&gt;&lt;/a&gt;kafka&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;Kafka 是一种高吞吐量的分布式发布订阅消息系统&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>常用的分布式事务解决方案介绍</title>
    <link href="http://yoursite.com/2018/07/23/distributed-1/"/>
    <id>http://yoursite.com/2018/07/23/distributed-1/</id>
    <published>2018-07-24T02:16:18.000Z</published>
    <updated>2019-04-15T02:04:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.zhihu.com/question/64921387/answer/225784480" target="_blank" rel="noopener">https://www.zhihu.com/question/64921387/answer/225784480</a></p><p>关于分布式事务，工程领域主要讨论的是强一致性和最终一致性的解决方案。典型方案包括：</p><blockquote><p>两阶段提交（2PC, Two-phase Commit）方案<br>eBay 事件队列方案<br>TCC 补偿模式<br>缓存数据最终一致性  </p></blockquote><a id="more"></a><h3 id="一、一致性理论"><a href="#一、一致性理论" class="headerlink" title="一、一致性理论"></a>一、一致性理论</h3><p>分布式事务的目的是保障分库数据一致性，而跨库事务会遇到各种不可控制的问题，如个别节点永久性宕机，像单机事务一样的ACID是无法奢望的。另外，业界著名的CAP理论也告诉我们，对分布式系统，需要将数据一致性和系统可用性、分区容忍性放在天平上一起考虑。</p><p>两阶段提交协议（简称2PC）是实现分布式事务较为经典的方案，但2PC 的可扩展性很差，在分布式架构下应用代价较大，eBay 架构师Dan Pritchett 提出了BASE 理论，用于解决大规模分布式系统下的数据一致性问题。BASE 理论告诉我们：可以通过放弃系统在每个时刻的强一致性来换取系统的可扩展性。</p><h4 id="1、CAP理论"><a href="#1、CAP理论" class="headerlink" title="1、CAP理论"></a>1、CAP理论</h4><p>在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）3 个要素最多只能同时满足两个，不可兼得。其中，分区容忍性又是不可或缺的。<br><img src="/2018/07/23/distributed-1/1.png" alt="p1"></p><ul><li>一致性：分布式环境下多个节点的数据是否强一致。</li><li>可用性：分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限时间内返回结果。</li><li>分区容忍性：特指对网络分区的容忍性。</li></ul><p>举例：Cassandra、Dynamo 等，默认优先选择AP，弱化C；HBase、MongoDB 等，默认优先选择CP，弱化A。</p><h4 id="2、BASE-理论"><a href="#2、BASE-理论" class="headerlink" title="2、BASE 理论"></a>2、BASE 理论</h4><p>核心思想：</p><ul><li>基本可用（BasicallyAvailable）：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。</li><li>软状态（SoftState）：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。</li><li>最终一致性（EventualConsistency）：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态。</li></ul><h3 id="二、一致性模型"><a href="#二、一致性模型" class="headerlink" title="二、一致性模型"></a>二、一致性模型</h3><p>数据的一致性模型可以分成以下 3 类：</p><ul><li><p>强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。</p></li><li><p>弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。</p></li><li><p>最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。</p></li></ul><p>分布式系统数据的强一致性、弱一致性和最终一致性可以通过Quorum NRW算法分析。</p><h3 id="三、分布式事务解决方案"><a href="#三、分布式事务解决方案" class="headerlink" title="三、分布式事务解决方案"></a>三、分布式事务解决方案</h3><h4 id="1、2PC方案——强一致性"><a href="#1、2PC方案——强一致性" class="headerlink" title="1、2PC方案——强一致性"></a>1、2PC方案——强一致性</h4><p>2PC的核心原理是通过提交分阶段和记日志的方式，记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试，如Coordinator重启后，通过日志可以确定提交处于Prepare还是PrepareAll状态，若是前者，说明有节点可能没有Prepare成功，或所有节点Prepare成功但还没有下发Commit，状态恢复后给所有节点下发RollBack；若是PrepareAll状态，需要给所有节点下发Commit，数据库节点需要保证Commit幂等。<br><img src="/2018/07/23/distributed-1/2.png" alt="p2"></p><p>2PC方案的问题：</p><ul><li>同步阻塞。</li><li>数据不一致。</li><li>单点问题</li></ul><p>升级的3PC方案旨在解决这些问题，主要有两个改进：</p><ul><li>增加超时机制。</li><li>两阶段之间插入准备阶段。</li></ul><p>但三阶段提交也存在一些缺陷，要彻底从协议层面避免数据不一致，可以采用Paxos或者Raft 算法。</p><h4 id="2、eBay事件队列方案——最终一致性"><a href="#2、eBay事件队列方案——最终一致性" class="headerlink" title="2、eBay事件队列方案——最终一致性"></a>2、eBay事件队列方案——最终一致性</h4><p>eBay的架构师Dan Pritchett，曾在一篇解释BASE原理的论文《Base：An Acid Alternative》中提到一个eBay 分布式系统一致性问题的解决方案。它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。</p><p>描述的场景为，有用户表user 和交易表transaction，用户表存储用户信息、总销售额和总购买额，交易表存储每一笔交易的流水号、买家信息、卖家信息和交易金额。如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。<br><img src="/2018/07/23/distributed-1/3.png" alt="p3"></p><p>论文中提出的解决方法是将更新交易表记录和用户表更新消息放在一个本地事务来完成，为了避免重复消费用户表更新消息带来的问题，增加一个操作记录表updates_applied来记录已经完成的交易相关的信息。<br><img src="/2018/07/23/distributed-1/4.png" alt="p4"></p><p>这个方案的核心在于第二阶段的重试和幂等执行。失败后重试，这是一种补偿机制，它是能保证系统最终一致的关键流程。</p><h4 id="3、TCC（Try-Confirm-Cancel）补偿模式——最终一致性"><a href="#3、TCC（Try-Confirm-Cancel）补偿模式——最终一致性" class="headerlink" title="3、TCC（Try-Confirm-Cancel）补偿模式——最终一致性"></a>3、TCC（Try-Confirm-Cancel）补偿模式——最终一致性</h4><p>某业务模型如图，由服务 A、服务B、服务C、服务D 共同组成的一个微服务架构系统。服务A 需要依次调用服务B、服务C 和服务D 共同完成一个操作。当服务A 调用服务D 失败时，若要保证整个系统数据的一致性，就要对服务B 和服务C 的invoke 操作进行回滚，执行反向的revert 操作。回滚成功后，整个微服务系统是数据一致的。<br><img src="/2018/07/23/distributed-1/5.png" alt="p5"></p><p>实现关键要素：</p><ul><li>服务调用链必须被记录下来。</li><li>每个服务提供者都需要提供一组业务逻辑相反的操作，互为补偿，同时回滚操作要保证幂等。</li><li>必须按失败原因执行不同的回滚策略。</li></ul><h4 id="4、缓存数据最终一致性"><a href="#4、缓存数据最终一致性" class="headerlink" title="4、缓存数据最终一致性"></a>4、缓存数据最终一致性</h4><p>在我们的业务系统中，缓存（Redis 或者Memcached）通常被用在数据库前面，作为数据读取的缓冲，使得I/O 操作不至于直接落在数据库上。以商品详情页为例，假如卖家修改了商品信息，并写回到数据库，但是这时候用户从商品详情页看到的信息还是从缓存中拿到的过时数据，这就出现了缓存系统和数据库系统中的数据不一致的现象。</p><p>要解决该场景下缓存和数据库数据不一致的问题我们有以下两种解决方案：</p><ul><li>为缓存数据设置过期时间。当缓存中数据过期后，业务系统会从数据库中获取数据，并将新值放入缓存。这个过期时间就是系统可以达到最终一致的容忍时间。</li><li>更新数据库数据后同时清除缓存数据。数据库数据更新后，同步删除缓存中数据，使得下次对商品详情的获取直接从数据库中获取，并同步到缓存。</li></ul><h3 id="四、选择建议"><a href="#四、选择建议" class="headerlink" title="四、选择建议"></a>四、选择建议</h3><p>在面临数据一致性问题的时候，首先要从业务需求的角度出发，确定我们对于3 种一致性模型的接受程度，再通过具体场景来决定解决方案。</p><p>从应用角度看，分布式事务的现实场景常常无法规避，在有能力给出其他解决方案前，2PC也是一个不错的选择。</p><p>对购物转账等电商和金融业务，中间件层的2PC最大问题在于业务不可见，一旦出现不可抗力或意想不到的一致性破坏，如数据节点永久性宕机，业务难以根据2PC的日志进行补偿。金融场景下，数据一致性是命根，业务需要对数据有百分之百的掌控力，建议使用TCC这类分布式事务模型，或基于消息队列的柔性事务框架，这两种方案都在业务层实现，业务开发者具有足够掌控力，可以结合SOA框架来架构，包括Dubbo、Spring Cloud等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.zhihu.com/question/64921387/answer/225784480&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/64921387/answer/225784480&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于分布式事务，工程领域主要讨论的是强一致性和最终一致性的解决方案。典型方案包括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两阶段提交（2PC, Two-phase Commit）方案&lt;br&gt;eBay 事件队列方案&lt;br&gt;TCC 补偿模式&lt;br&gt;缓存数据最终一致性  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>服务器部署篇（三）：php.ini 配置调优 —— 让 PHP 应用性能维持在更高水平</title>
    <link href="http://yoursite.com/2018/07/22/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-3/"/>
    <id>http://yoursite.com/2018/07/22/服务器部署-3/</id>
    <published>2018-07-22T06:22:31.000Z</published>
    <updated>2019-04-12T09:23:27.056Z</updated>
    
    <content type="html"><![CDATA[<p>默认安装的 PHP 就像是在百货商店里购买的普通套装，虽然合身，却不完美。调优的 PHP 就像是定做的套装，完全匹配你的尺寸。<a id="more"></a>不过，需要注意的是，调优 PHP 只是提升 PHP 性能和效率的举措，对拙劣的代码和无响应的 API 调用无计可施。</p><h4 id="php-ini文件"><a href="#php-ini文件" class="headerlink" title="php.ini文件"></a>php.ini文件</h4><p>PHP 解释器在 php.ini 文件中配置和调优，这个文件在不同操作系统中的位置有所不同，而且一般命令行对应的 php.ini 和 PHP-FPM 对应的 php.ini 文件是分开的。这里我们假设配置的是 PHP-FPM 对应的 php.ini，但是下面讲的优化措施适用于所有 php.ini。</p><blockquote><p>注：我们首先应该使用 PHP Iniscan 工具扫描 php.ini，检查使用了安全方面的最佳实践。</p></blockquote><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>运行 PHP 时需要关心每个 PHP 进程要使用多少内存，php.ini 中的 memory_limit 设置用于设定单个 PHP 进程可以使用的系统内存最大值。</p><p>这个设置的默认值是 128M，这对于大多数中小型 PHP 应用来说或许合适，不过，如果运行的是微型 PHP 应用，可以降低这个值，以便节省系统资源，反之，如果运行的是内存集中型 PHP 应用，可以增加这个值。这个值的大小由可用的系统内存决定，确定给 PHP 分配多少值是一门艺术，决定给 PHP 分配多少内存，以及能负担起多少个 PHP-FPM 进程时，可以根据以下维度信息进行判断：</p><ul><li>一共可以分配给 PHP 多少内存？以一个 2G 内存的 VPS 为例，这台设备中可能还运行了其他进程，如 MySQL、Nginx 等，那么留 512M 给 PHP 是合适的。</li><li>每个 PHP 进程平均耗费多少内存？这个要监控进程的内存使用量，可以使用命令行命令 top，也可以在 PHP 脚本中调用 memory_get_peak_usage() 函数，不管使用哪种方式，都要多次运行同一个脚本，然后取内存消耗的平均值。</li><li>能负担起多少个 PHP-FPM 进程？假设我给 PHP 分配了 512M 内存，每个 PHP 进程平均耗费 15M 内存，那么可以负担起 34 个 PHP-FPM 进程。</li><li>有足够的系统资源吗？最后还需要确认有足够的系统资源运行 PHP 应用并处理预期的流量。</li></ul><blockquote><p>注：我们应该使用 Apache Bench 或 Siege 在类似生产环境的条件下对 PHP 应用做压力测试，以确定生产环境是否有足够的资源可用。</p></blockquote><h4 id="Zend-OPcache"><a href="#Zend-OPcache" class="headerlink" title="Zend OPcache"></a>Zend OPcache</h4><p>确定要分配多少内存后，就可以配置 PHP 的 Zend OPcache 扩展，关于这个扩展的详细信息可参考这篇文章：<a href="http://laravelacademy.org/post/4396.html。" target="_blank" rel="noopener">http://laravelacademy.org/post/4396.html。</a></p><p>PHP 5.5.0+ 内置了这个扩展，下面是在 php.ini 文件中配置和优化 Zend OPcache 扩展所用的设置：</p><ul><li>opcache.memory_consumption = 64：为操作码缓存分配的内存（单位是MB），分配的内存量应该可以保存应用中所有 PHP 脚本编译得到的操作码，这个值根据应用的体量可以设置成不同大小的值。</li><li>opcache.interned_strings_buffer = 16：用来存储驻留字符串的内存量（单位是MB），什么是驻留字符串呢？PHP 解释器在背后会找到相同字符串的多个实例，把这个字符串保存在内存中，如果再次使用相同的字符串，PHP 解释器会使用指针，这么做的目的是节省内存。默认情况下，PHP 驻留字符串会隔离在各个 PHP 进程中，这个设置能让 PHP-FPM 进程池把所有进程驻留字符串存储到共享的缓冲区中，以便在 PHP-FPM 进程池中的多个进程之间引用驻留字符串，这样能节省更多内存。</li><li>opcache.max_accelerated_files = 4000：操作码缓存中最多能存储多少个 PHP 脚本，这个值的区间是 2000 到 100000 之间，这个值一定要比 PHP 应用中的文件数大。</li><li>opcache.validate_timestamps = 1：这个设置的值为1时，经过一段时间后 PHP 会检查 PHP 脚本的内容是否有变化，检查的时间间隔由 opcache.revalidate_freq 设置指定。如果这个设置的值为0，PHP 不会检查 PHP 脚本的内容是否有变化，我们必须自己动手清除缓存的操作码。建议在开发环境中设置为1，生产环境中设置为0。</li><li>opcache.revalidate_freq = 0：设置多久（单位是秒）检查一次 PHP 脚本内容是否有变化。设置为0秒的含义是仅当opcache.validate_timestamps 设置为1时，才会在每次请求时都重新验证 PHP 文件，因此，在开发环境中每次都会重新验证 PHP 文件，在生产环境中则不验证。</li><li>opcache.fast_shutdown = 1：这么设置能让操作码使用更快的停机步骤，把对象析构和内存释放交给 Zend Engine 的内存管理器完成。</li></ul><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>如果你的应用允许上传文件，最好设置最大能上传的文件大小。除此之外，最好还要设置最多能同时上传多少个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_uploads = 1</span><br><span class="line">upload_max_filesize = 10M</span><br><span class="line">max_file_uploads = 3</span><br></pre></td></tr></table></figure></p><p>默认情况下，PHP 允许在单次请求中上传 20 个文件，上传的文件最大为 2MB，这里我设置为单次请求最多只能上传 3 个文件，每个文件最大为 10MB，这个值不要设置太大，否则会出现超时。</p><blockquote><p>注：如果非要上传大文件，Web 服务器的配置也要做相应调整。除了在 php.ini 中设置之外，还要调整 Nginx 虚拟主机配置中的 client_max_body_size 设置。</p></blockquote><h4 id="最长执行时间"><a href="#最长执行时间" class="headerlink" title="最长执行时间"></a>最长执行时间</h4><p>php.ini 文件中的 max_execution_time 用于设置单个 PHP 进程在终止之前最长可运行时间。这个设置默认是 30 秒，建议将其设置为 5 秒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_execution_time = 5</span><br></pre></td></tr></table></figure><blockquote><p>注：在 PHP 脚本中可以调用 set_limit_time() 函数覆盖这个设置。</p></blockquote><p>假设我们想要生成报告，并把结果制作成 PDF 文件，这个任务可能要花 10 分钟才能完成，而我们肯定不想让 PHP 请求等待 10 分钟，我们应该单独编写一个 PHP 文件，让其在单独的后台进程中执行，Web 应用只需几毫秒就可以派生一个单独的后台进程，然后返回 HTTP 响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">exec(&apos;echo &quot;create-report.php&quot; | at now&apos;);</span><br><span class="line">echo &apos;report pending...&apos;;</span><br></pre></td></tr></table></figure><p>create-report.php 在单独的后台进程中运行，运行完毕后可以更新数据库，或者通过电子邮件把报告发给收件人。不过这种用法很少见，更多时候我们是通过异步消费队列来实现类似的功能，无论从安全性、扩展性、可维护性上来讲，效果更好，相关的组件有轻量级消息队列 PHPResque 等。</p><h4 id="处理会话"><a href="#处理会话" class="headerlink" title="处理会话"></a>处理会话</h4><p>PHP 默认的会话处理程序会拖慢大型应用，因为这个处理程序会把会话数据存储在硬盘中，需要创建不必要的磁盘 I/O，浪费时间。我们应该把会话数据保存在内存中，例如可以使用 Memcached 或 Redis。这么做还有个额外好处 —— 以后便于伸缩。如果会话数据存储在硬盘中，不便于增加额外的服务器，如果把会话数据存放在 Memcached 或 Redis 里，任何一台分布式 PHP-FPM 服务器都能访问会话数据。</p><p>如果想把会话数据保存在 Memcached 中，需要做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.save_handler = &apos;memcached&apos;</span><br><span class="line">session.save_path = &apos;127.0.0.1:11211&apos;</span><br></pre></td></tr></table></figure></p><h4 id="缓冲输出"><a href="#缓冲输出" class="headerlink" title="缓冲输出"></a>缓冲输出</h4><p>如果是在较少的块中发送更多数据，而不是在较多的块中发送较少的数据，那么网络的效率会更高，也就是说，在较少的片段中把内容传递给访问者的浏览器，能减少 HTTP 请求总数。</p><p>因此，我们要让 PHP 缓冲输出，默认情况下，PHP 已经启用了输出缓冲功能，PHP 缓冲 4096 字节的输出之后才会把内容发送给 Web 服务器，推荐配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output_buffering = 4096</span><br><span class="line">implicit_flush = false</span><br></pre></td></tr></table></figure><blockquote><p>注：如果想要修改输出缓冲区的大小，确保使用的值是4（32位系统）或8（64位系统）的倍数。</p></blockquote><h4 id="真实路径缓存"><a href="#真实路径缓存" class="headerlink" title="真实路径缓存"></a>真实路径缓存</h4><p>PHP 会缓存应用使用的文件路径，这样每次包含或导入文件时就无需不断搜索包含路径了，这个缓存叫真实路径缓存（realpath cache），如果运行的是大型的 PHP 文件（如 Composer 组件），使用了大量文件，增加 PHP 真实路径缓存的大小能得到更好的性能。</p><p>真实路径缓存的默认大小是 16K，这个缓存所需的准确大小不容易确定，不过可以使用一个小技巧：首先，增加真实路径缓存的大小，设置为特别大的一个值，如 256K，然后，在一个 PHP 脚本的末尾加上 print_r(realpath_cache_size());，输出真实路径缓存的真正大小，最后，把真实路径缓存的大小改为这个真正的值。我们可以在 php.ini 文件中设置真实路径缓存的大小：</p><blockquote><p>realpath_cache_size = 64K</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认安装的 PHP 就像是在百货商店里购买的普通套装，虽然合身，却不完美。调优的 PHP 就像是定做的套装，完全匹配你的尺寸。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>服务器部署篇（二）：在服务器上对 PHP-FPM 和 Nginx 进行安装配置详解</title>
    <link href="http://yoursite.com/2018/07/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-2/"/>
    <id>http://yoursite.com/2018/07/21/服务器部署-2/</id>
    <published>2018-07-21T06:12:26.000Z</published>
    <updated>2019-04-15T01:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码安装php7-2"><a href="#源码安装php7-2" class="headerlink" title="源码安装php7.2"></a>源码安装php7.2</h3><h4 id="选择需要的php版本"><a href="#选择需要的php版本" class="headerlink" title="选择需要的php版本"></a>选择需要的php版本</h4><p>从 php官网： <a href="http://cn2.php.net/downloads.php" target="_blank" rel="noopener">http://cn2.php.net/downloads.php</a> 选择需要的php版本，选择.tar.gz 的下载包，点击进入，选择中国的本地语言包，复制这个下载地址<br><img src="/2018/07/21/服务器部署-2/1.jpg" alt="p1"><br><a id="more"></a><br>选择地区镜像下载<br><img src="/2018/07/21/服务器部署-2/3.jpg" alt="p2"><br>地址：<a href="http://cn2.php.net/get/php-7.2.8.tar.gz/from/this/mirror" target="_blank" rel="noopener">http://cn2.php.net/get/php-7.2.8.tar.gz/from/this/mirror</a></p><h4 id="下载php源码"><a href="#下载php源码" class="headerlink" title="下载php源码"></a>下载php源码</h4><ul><li>选择一个位置存放文件<br>cd /usr/src/</li><li>下载刚刚选好的php压缩包<br>wget <a href="http://cn2.php.net/get/php-7.2.8.tar.gz/from/this/mirror" target="_blank" rel="noopener">http://cn2.php.net/get/php-7.2.8.tar.gz/from/this/mirror</a><br>但是我们下载下来看到并不是我们要的php-7.2.8.tar.gz 类似的压缩文件，而是一个mirror的文件，很简单，我们给文件重命名就可以了<br>mv mirror php-7.2.8.tar.gz </li><li>安装php所需要的依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc</span><br><span class="line">yum install libxml2</span><br><span class="line">yum install libxml2-devel</span><br><span class="line">yum install openssl openssl-devel</span><br><span class="line">yum -y install curl-devel</span><br><span class="line">yum install libjpeg.x86_64 libpng.x86_64 freetype.x86_64 libjpeg-devel.x86_64 libpng-devel.x86_64 freetype-devel.x86_64 -y</span><br><span class="line">yum install bzip2-devel.x86_64 -y</span><br><span class="line">yum install libXpm-devel</span><br><span class="line">yum install gmp-devel</span><br><span class="line">yum install -y icu libicu libicu-devel</span><br><span class="line">yum  install  php-mcrypt  libmcrypt  libmcrypt-devel</span><br><span class="line">yum install  postgresql-devel</span><br><span class="line">yum install libxslt-devel</span><br></pre></td></tr></table></figure><ul><li>解压编译 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -xzxvf php-7.2.0.tar.gz  </span><br><span class="line"> cd php-7.2.0  </span><br><span class="line"> 设置编译需要加载的模块  </span><br><span class="line"> ./configure --prefix=/usr/local/php --with-pdo-pgsql --with-zlib-dir --with-freetype-dir --enable-mbstring --with-libxml-dir=/usr --enable-soap --enable-calendar --with-curl --with-mcrypt --with-gd --with-pgsql --disable-rpath --enable-inline-optimization --with-bz2 --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --enable-exif --enable-bcmath --with-mhash --enable-zip --with-pcre-regex --with-pdo-mysql --with-mysqli --with-jpeg-dir=/usr --with-png-dir=/usr --enable-gd-native-ttf --with-openssl --with-fpm-user=www-data --with-fpm-group=www-data --with-libdir=/lib/x86_64-linux-gnu/--enable-ftp --with-gettext --with-xmlrpc --with-xsl --enable-opcache --enable-fpm --with-iconv --with-xpm-dir=/usr  </span><br><span class="line"> 编译： </span><br><span class="line"> make clean &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ul><li>复制配置文件 </li></ul><blockquote><p>cp php.ini-development /usr/local/php/lib/php.ini  </p></blockquote><ul><li>设置全局的php命令</li></ul><blockquote><p>设置软连接即可<br>ln -s /usr/local/php/bin /usr/local/bin</p></blockquote><p>可以通过php -v 查看php版本信息或者php -m 看看刚刚编译加载的模块了</p><h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>PHP-FPM（PHP FastCGI Process Manager），是用于管理 PHP 进程池的软件，用于接收和处理来自 Web 服务器（如Nginx）的请求。PHP-FPM会创建一个主进程（通常以操作系统中根用户的身份运行），控制何时以及如何把 HTTP 请求转发给一个或多个子进程处理。PHP-FPM 主进程还控制着什么时候创建和销毁 PHP 子进程。PHP-FPM 进程池中的每个进程存在的时间都比单个 HTTP 请求长，可以处理10、50、100或更多的 HTTP 请求。</p><h4 id="配置PHP-fpm"><a href="#配置PHP-fpm" class="headerlink" title="配置PHP-fpm"></a>配置PHP-fpm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf  </span><br><span class="line">cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf  </span><br><span class="line">cp /usr/src/php-7.2.8/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm  </span><br><span class="line">chmod +x /etc/init.d/php-fpm</span><br></pre></td></tr></table></figure><p>新建www-data 用户组：</p><blockquote><p>groupadd www-data<br>useradd -g www-data www-data  </p></blockquote><p>启动php-fpm </p><blockquote><p>/etc/init.d/php-fpm start </p></blockquote><p>(可选)配置php-fpm自启动，如果存在这个文件，这步省略<br>创建php-fpm启动脚本  </p><blockquote><p>vim /etc/init.d/php-fpm</p></blockquote><p>插入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh  </span><br><span class="line"># chkconfig:   2345 15 95</span><br><span class="line"></span><br><span class="line"># description:  PHP-FPM (FastCGI Process Manager) is an alternative PHP FastCGI implementation \</span><br><span class="line"></span><br><span class="line"># with some additional features useful for sites of any size, especially busier sites.</span><br><span class="line"># DateTime: 2016-09-20</span><br><span class="line"></span><br><span class="line"># Source function library.  </span><br><span class="line">. /etc/rc.d/init.d/functions  </span><br><span class="line"></span><br><span class="line"># Source networking configuration.  </span><br><span class="line">. /etc/sysconfig/network  </span><br><span class="line"></span><br><span class="line"># Check that networking is up.  </span><br><span class="line">[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0  </span><br><span class="line"></span><br><span class="line">phpfpm=&quot;/usr/local/php/sbin/php-fpm&quot;  </span><br><span class="line">prog=$(basename $&#123;phpfpm&#125;)  </span><br><span class="line"></span><br><span class="line">lockfile=/var/lock/subsys/phpfpm</span><br><span class="line"></span><br><span class="line">start() &#123;  </span><br><span class="line">    [ -x $&#123;phpfpm&#125; ] || exit 5  </span><br><span class="line">    echo -n $&quot;Starting $prog: &quot;  </span><br><span class="line">    daemon $&#123;phpfpm&#125;</span><br><span class="line">    retval=$?  </span><br><span class="line">    echo  </span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; touch $lockfile  </span><br><span class="line">    return $retval  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">stop() &#123;  </span><br><span class="line">    echo -n $&quot;Stopping $prog: &quot;  </span><br><span class="line">    killproc $prog -QUIT  </span><br><span class="line">    retval=$?  </span><br><span class="line">    echo  </span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile  </span><br><span class="line">    return $retval  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">restart() &#123;  </span><br><span class="line">    configtest || return $?  </span><br><span class="line">    stop  </span><br><span class="line">    start  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">reload() &#123;  </span><br><span class="line">    configtest || return $?  </span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;  </span><br><span class="line">    killproc $&#123;phpfpm&#125; -HUP  </span><br><span class="line">    RETVAL=$?  </span><br><span class="line">    echo  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">force_reload() &#123;  </span><br><span class="line">    restart  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">configtest() &#123;  </span><br><span class="line">  $&#123;phpfpm&#125; -t</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">rh_status() &#123;  </span><br><span class="line">    status $prog  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">rh_status_q() &#123;  </span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in  </span><br><span class="line">    start)  </span><br><span class="line">        rh_status_q &amp;&amp; exit 0  </span><br><span class="line">        $1  </span><br><span class="line">        ;;  </span><br><span class="line">    stop)  </span><br><span class="line">        rh_status_q || exit 0  </span><br><span class="line">        $1  </span><br><span class="line">        ;;  </span><br><span class="line">    restart|configtest)  </span><br><span class="line">        $1  </span><br><span class="line">        ;;  </span><br><span class="line">    reload)  </span><br><span class="line">        rh_status_q || exit 7  </span><br><span class="line">        $1  </span><br><span class="line">        ;;  </span><br><span class="line">    status)  </span><br><span class="line">        rh_status  </span><br><span class="line">        ;;  </span><br><span class="line">    *)  </span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|status|restart|reload|configtest&#125;&quot;  </span><br><span class="line">        exit 2  </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>添加到开机启动项   </p><blockquote><p>chkconfig –add php-fpm</p></blockquote><p>此时也可以使用service来启动php-fpm了</p><blockquote><p>service php-fpm start<br>service php-fpm stop</p></blockquote><h3 id="yum安装nginx"><a href="#yum安装nginx" class="headerlink" title="yum安装nginx"></a>yum安装nginx</h3><h4 id="执行yum安装命令"><a href="#执行yum安装命令" class="headerlink" title="执行yum安装命令"></a>执行yum安装命令</h4><blockquote><p>yum install nginx </p></blockquote><h4 id="修改配置文件已支持php"><a href="#修改配置文件已支持php" class="headerlink" title="修改配置文件已支持php"></a>修改配置文件已支持php</h4><blockquote><p>cd /etc/nginx/ </p></blockquote><p>删掉原本的nginx.conf，复制一份nginx.conf.default的默认配置</p><blockquote><p>rm -rf nginx.conf<br> cp nginx.conf.default nginx.conf<br> vim nginx.conf  </p></blockquote><p>server里面的配置：<br>在location / 的中index增加index.php ，增加URL重写读取;<br>解开location ~ .php$的注释，修改fastcgi的路径，最终server部分配置内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">         listen       80;</span><br><span class="line">         server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">          #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">          location / &#123;</span><br><span class="line">              root   html;</span><br><span class="line">              # 修改1：这里新增了index.php</span><br><span class="line">              index index.html index.htm index.php;</span><br><span class="line">              # 修改2：这里新增url重写（path）</span><br><span class="line">              try_files $uri $uri/ /index.php$is_args$args;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">          # redirect server error pages to the static page /50x.html</span><br><span class="line">          #</span><br><span class="line">          error_page   500 502 503 504  /50x.html;</span><br><span class="line">          location = /50x.html &#123;</span><br><span class="line"></span><br><span class="line">             root   html;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">          #</span><br><span class="line">          #location ~ \.php$ &#123;</span><br><span class="line">          #    proxy_pass   http://127.0.0.1;</span><br><span class="line">          #&#125;</span><br><span class="line"></span><br><span class="line">          # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">          #</span><br><span class="line">    #修改3：解开php支持的注释</span><br><span class="line">          location ~ \.php$ &#123;</span><br><span class="line">              root           html;</span><br><span class="line">              #默认就使用php-fpm</span><br><span class="line">              fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">              fastcgi_index  index.php;</span><br><span class="line">              #修改4：修改fastcig的路径</span><br><span class="line">              fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">              include        fastcgi_params;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">          # concurs with nginx&apos;s one</span><br><span class="line">          #</span><br><span class="line">          #location ~ /\.ht &#123;</span><br><span class="line">          #    deny  all;</span><br><span class="line">          #&#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>保存配置文件。 </p><h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><p>service nginx start </p><h4 id="（可选）设置nginx开机自启动"><a href="#（可选）设置nginx开机自启动" class="headerlink" title="（可选）设置nginx开机自启动"></a>（可选）设置nginx开机自启动</h4><p>创建nginx启动命令脚本 </p><p>vim /etc/init.d/nginx  </p><p>插入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">! /bin/bash</span><br><span class="line"> chkconfig: - 85 15</span><br><span class="line">PATH=/usr/local/nginx</span><br><span class="line">DESC=&quot;nginx daemon&quot;</span><br><span class="line">NAME=nginx</span><br><span class="line">DAEMON=$PATH/sbin/$NAME</span><br><span class="line">CONFIGFILE=$PATH/conf/$NAME.conf</span><br><span class="line">PIDFILE=$PATH/logs/$NAME.pid</span><br><span class="line">SCRIPTNAME=/etc/init.d/$NAME</span><br><span class="line">set -e</span><br><span class="line">[ -x &quot;$DAEMON&quot; ] || exit 0</span><br><span class="line">do_start() &#123;</span><br><span class="line">$DAEMON -c $CONFIGFILE || echo -n &quot;nginx already running&quot;</span><br><span class="line">&#125;</span><br><span class="line">do_stop() &#123;</span><br><span class="line">$DAEMON -s stop || echo -n &quot;nginx not running&quot;</span><br><span class="line">&#125;</span><br><span class="line">do_reload() &#123;</span><br><span class="line">$DAEMON -s reload || echo -n &quot;nginx can&apos;t reload&quot;</span><br><span class="line">&#125;</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">echo -n &quot;Starting $DESC: $NAME&quot;</span><br><span class="line">do_start</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo -n &quot;Stopping $DESC: $NAME&quot;</span><br><span class="line">do_stop</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">reload|graceful)</span><br><span class="line">echo -n &quot;Reloading $DESC configuration...&quot;</span><br><span class="line">do_reload</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">echo -n &quot;Restarting $DESC: $NAME&quot;</span><br><span class="line">do_stop</span><br><span class="line">do_start</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: $SCRIPTNAME &#123;start|stop|reload|restart&#125;&quot; &gt;&amp;2</span><br><span class="line">exit 3</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>设置执行权限  </p><blockquote><p>chmod a+x /etc/init.d/nginx </p></blockquote><p>注册成服务  </p><blockquote><p>chkconfig –add nginx </p></blockquote><p>设置开机启动  </p><blockquote><p>chkconfig nginx on </p></blockquote><p>重启查看nginx服务是否自动启动（！！！ 请确保重启不会影响现有业务，如不确定请不要执行，后果自负）</p><blockquote><p>shutdown -h 0 -r<br>netstat -apn|grep nginx  </p></blockquote><p>配置nginx成服务还有一个好处就是可以直接通过systemctl或者service直接启动或停止nginx了，例如 systemctl stop nginx 或者 service nginx stop就可以停止nginx了</p><h4 id="编写测试文件"><a href="#编写测试文件" class="headerlink" title="编写测试文件"></a>编写测试文件</h4><blockquote><p>vim /usr/share/nginx/html/phpinfo.php </p></blockquote><p>比如编辑一个phpinfo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br></pre></td></tr></table></figure></p><p>最后就可以访问刚刚这个文件了 </p><h3 id="yum安装mysql5-7"><a href="#yum安装mysql5-7" class="headerlink" title="yum安装mysql5.7"></a>yum安装mysql5.7</h3><h4 id="获取mysql-YUM源"><a href="#获取mysql-YUM源" class="headerlink" title="获取mysql YUM源"></a>获取mysql YUM源</h4><blockquote><p>wget <a href="https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm" target="_blank" rel="noopener">https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</a></p></blockquote><h4 id="安装mysql源"><a href="#安装mysql源" class="headerlink" title="安装mysql源"></a>安装mysql源</h4><blockquote><p>yum -y localinstall mysql57-community-release-el7-11.noarch.rpm</p></blockquote><h4 id="在线安装Mysql"><a href="#在线安装Mysql" class="headerlink" title="在线安装Mysql"></a>在线安装Mysql</h4><blockquote><p>yum -y install mysql-community-server</p></blockquote><h4 id="启动Mysql服务"><a href="#启动Mysql服务" class="headerlink" title="启动Mysql服务"></a>启动Mysql服务</h4><blockquote><p>systemctl start mysqld<br>（service mysqld start 也行）</p></blockquote><h4 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h4><blockquote><p>systemctl enable mysqld<br>systemctl daemon-reload  </p></blockquote><h4 id="修改root本地登录密码"><a href="#修改root本地登录密码" class="headerlink" title="修改root本地登录密码"></a>修改root本地登录密码</h4><p>mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个临时的默认密码。</p><blockquote><p>[root@localhost ~]# vi /var/log/mysqld.log</p></blockquote><p>这里的临时密码 eMV.R#mWe3ha</p><blockquote><p>[root@localhost ~]# mysql -u root -p<br>Enter password:  </p></blockquote><p>输入临时密码 进入mysql命令行；</p><blockquote><p>mysql&gt; ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘Sean123456@’;<br>Query OK, 0 rows affected (0.00 sec)</p></blockquote><p>修改密码为 Sean123456@ (备注 mysql5.7默认密码策略要求密码必须是大小写字母数字特殊字母的组合，至少8位)</p><h4 id="设置允许远程登录"><a href="#设置允许远程登录" class="headerlink" title="设置允许远程登录"></a>设置允许远程登录</h4><p>Mysql默认不允许远程登录，我们需要设置下，并且防火墙开放3306端口；</p><blockquote><p>mysql&gt; GRANT ALL PRIVILEGES ON . TO ‘root’@’%’ IDENTIFIED BY ‘ZhipengWang2012@’ WITH GRANT OPTION;<br>Query OK, 0 rows affected, 1 warning (0.01 sec)<br>mysql&gt; exit;<br>Bye</p></blockquote><p>这里其实最好新建一个用户： </p><blockquote><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘adduser‘@’%’ IDENTIFIED BY ‘SeanTest’ WITH GRANT OPTION;</p></blockquote><p>开放3306端口 </p><blockquote><p>firewall-cmd –zone=public –add-port=3306/tcp –permanent<br>重启防火墙<br>firewall-cmd –reload  </p></blockquote><h4 id="配置默认编码为utf8"><a href="#配置默认编码为utf8" class="headerlink" title="配置默认编码为utf8"></a>配置默认编码为utf8</h4><p>修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：</p><blockquote><p>[mysqld]<br>character_set_server=utf8<br>init_connect=’SET NAMES utf8’<br>vim /etc/my.cnf  </p></blockquote><p>编辑保存完 重启mysql服务； </p><blockquote><p>systemctl restart mysqld</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;源码安装php7-2&quot;&gt;&lt;a href=&quot;#源码安装php7-2&quot; class=&quot;headerlink&quot; title=&quot;源码安装php7.2&quot;&gt;&lt;/a&gt;源码安装php7.2&lt;/h3&gt;&lt;h4 id=&quot;选择需要的php版本&quot;&gt;&lt;a href=&quot;#选择需要的php版本&quot; class=&quot;headerlink&quot; title=&quot;选择需要的php版本&quot;&gt;&lt;/a&gt;选择需要的php版本&lt;/h4&gt;&lt;p&gt;从 php官网： &lt;a href=&quot;http://cn2.php.net/downloads.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cn2.php.net/downloads.php&lt;/a&gt; 选择需要的php版本，选择.tar.gz 的下载包，点击进入，选择中国的本地语言包，复制这个下载地址&lt;br&gt;&lt;img src=&quot;/2018/07/21/服务器部署-2/1.jpg&quot; alt=&quot;p1&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>服务器部署篇（一）：服务器主机选择及初始化配置 —— 新增用户及密钥对认证</title>
    <link href="http://yoursite.com/2018/07/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-1/"/>
    <id>http://yoursite.com/2018/07/19/服务器部署-1/</id>
    <published>2018-07-19T20:02:21.000Z</published>
    <updated>2019-04-12T09:23:26.116Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><p>PHP 应用开发好了之后，还需要部署到远程主机上，才能让用户访问我们提供的服务。<a id="more"></a>一般来说，目前市场上提供的主机有四种：共享服务器、虚拟私有服务器（VPS）、专用服务器和 PaaS。每种主机适用场景不同，相应的价格差距也很大。</p><h4 id="共享服务器"><a href="#共享服务器" class="headerlink" title="共享服务器"></a>共享服务器</h4><p>这种最便宜，一般来说这种适用于非开发者部署网站，比如非程序员出生的站长，部署 WordPress、Discuz 之类的 CMS 网站，不需要懂代码，也不需要配置服务器环境，只需通过 Web 界面操作即可，这种类型的主机资源由很多人共享，存放在不同类目，从安全和性能上来说都很差，而且不允许用户远程登录，支持的软件和扩展有限，不建议开发者使用这种类型的主机。市面上常见的香港主机、美国主机就属于这种服务器。</p><h4 id="虚拟私有服务器"><a href="#虚拟私有服务器" class="headerlink" title="虚拟私有服务器"></a>虚拟私有服务器</h4><p>虚拟私有服务器就是我们常说的 VPS，这种类型的主机不是物理上的独立主机，而是逻辑上的独立主机，由一些列系统资源组成，分布在多台服务器中，但是拥有自己独立的文件系统、根用户、系统进程和 IP 地址，内存、CPU和带宽是固定的，所以感觉上就是一台独立的主机。我们可以 SSH 远程登录，安装自己需要的软件，对服务器配置进行调优和修改，所以拥有更多的自主性，当然价格也要贵一些。典型代表有 Linode 等。</p><h4 id="专用服务器"><a href="#专用服务器" class="headerlink" title="专用服务器"></a>专用服务器</h4><p>专用服务器是机架式设备，由主机商代你安装、运行和维护，我们可以根据自己制定的规格配置专用服务器。专用服务器是真实的物理设备，安装、配置和维护成本较高，但是能提供更好的性能，一般大公司如 BAT 都会部署这种类型主机。</p><p>PaaS<br>使用云计算提供的平台即服务（PaaS）能快速发布 PHP 应用，与虚拟私有服务器和专用服务器不同，我们无需管理 PaaS，只需登录 PaaS 提供商的控制面板，点击按钮即可。常见的 PaaS 如下：</p><ul><li>Amazon AWS</li><li>阿里云</li><li>百度云</li><li>腾讯云</li><li>Google App Engine</li><li>Microsoft Azure</li></ul><p>各个云计算提供商的价格有所不同，但基本和 VPS 持平。</p><h3 id="选择主机方案"><a href="#选择主机方案" class="headerlink" title="选择主机方案"></a>选择主机方案</h3><p>我们要根据自己的需求选择合适的主机方案，对于中小型 PHP 应用，使用 VPS 或 PaaS 是最佳选择，目前来说，云计算服务越来越发达，提供的功能越来越丰富，PaaS 是最佳选择。国内的话就阿里云 ECS 了。</p><h3 id="设置服务器"><a href="#设置服务器" class="headerlink" title="设置服务器"></a>设置服务器</h3><h4 id="首次登录"><a href="#首次登录" class="headerlink" title="首次登录"></a>首次登录</h4><p>首先，我们需要登录新买的服务器，在本地设备中打开终端，执行 ssh 命令，登录服务器：</p><blockquote><p>ssh root@your_server_ip_address</p></blockquote><p>这个命令可能会让你确认新服务器的可靠性，输入 yes 并回车即可。</p><p>接下来需要输入根用户的密码，一般购买服务器后服务器提供商会给你根用户的密码，输入该密码登录即可。</p><p>登录之后，我们可以升级下操作系统的软件：</p><blockquote><p># Ubuntu<br>apt-get update;<br>apt-get upgrade;  </p><p># CentOS<br>yum update  </p></blockquote><h4 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h4><p>我们要创建一个非根用户执行以后的日常操作以提高系统安全性，由于根用户拥有一切权限，所以我们应该尽量避免登录该用户。</p><p>下面我们以 Ubuntu 系统为例，演示如何创建新用户 deploy：</p><blockquote><p># 创建用户<br>adduser deploy<br># 让用户拥有sudo权限<br>usermod -a -G sudo deploy<br># 设置用户密码<br>passwd deploy  </p></blockquote><p>对于 CentOS 用户对应操作如下：</p><blockquote><p># 创建用户<br>adduser deploy<br># 让用户拥有sudo权限<br>usermod -a -G wheel deploy<br># 设置用户密码<br>passwd deploy  </p></blockquote><h4 id="SSH-密钥对认证"><a href="#SSH-密钥对认证" class="headerlink" title="SSH 密钥对认证"></a>SSH 密钥对认证</h4><p>创建完新用户后，在本地设备以如下方式登录服务器：</p><blockquote><p>ssh deploy@your_server_ip_address</p></blockquote><p>这个命令需要输入该用户密码后才能登录，我们可以禁用密码登录，以提高系统安全性，密码认证有漏洞，会遭受暴力攻击。对此，我们的解决方案就是使用密钥对认证。</p><p>密钥对认证是个复杂的话题，简单来说，我们在本地设备中创建一对「密钥」，其中一个是私钥（保存在本地），另一个是公钥（传到远程服务器），之所以叫密钥对，是因为使用公钥加密的信息只能使用私钥解密。</p><p>使用 SSH 密钥对认证方式登录远程服务器时，远程服务器会随机创建一个消息，使用公钥加密，然后把密文发送给本地设备，本地设备收到密文后使用私钥解密，然后把解密后的消息发送给远程服务器，远程服务器验证解密消息后，再授予访问远程服务器的权限。</p><p>需要指出的是，如果是多台电脑需要登录远程服务器，这或许不是最好的方式，因为需要在每台电脑中生成 SSH 密钥对，然后再把每个密钥对中的公钥复制到远程服务器中。这种情况下，最好还是使用安全的密码进行登录。不过，如果只有一台本地电脑访问远程服务器，SSH 密钥对认证是最好的方式。</p><p>生成 SSH 密钥对的方式是使用以下指令：</p><blockquote><p>ssh-keygen</p></blockquote><p>然后按照屏幕上显示的内容，按照提示输入所需要的信息。这个命令会在本地创建两个文件：~/.ssh/id_rsa.pub（公钥）和 ~/.ssh/id_rsa（私钥）。私钥应该保存在本地电脑中，而且要保密，公钥必须复制到服务器中，我们可以使用 scp （安全复制）命令复制公钥：</p><blockquote><p>scp ~/.ssh/id_rsa.pub deploy@your_server_ip_address:<br>注：一定要在末尾加上:符号，这会把公钥复制到远程服务器中 deploy 用户的家目录。  </p></blockquote><p>接下来，以 deploy 用户的身份登录远程服务器，登录后，确认 ~/.ssh 目录是否存在，如果不存在，需要执行下面的命令手动创建：</p><blockquote><p>mkdir ~/.ssh</p></blockquote><p>然后执行下面的命令创建 ~/.ssh/authorized_keys 文件：</p><blockquote><p>touch ~/.ssh/authorized_keys</p></blockquote><p>这个文件的内容是一系列允许登录这台远程服务器的公钥。执行下面的命令，把刚上传的公钥添加到 ~/.ssh/authorized_keys 文件中：</p><blockquote><p>cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</p></blockquote><p>最后，我们需要修改几个目录和文件的权限，只让 deploy 用户访问 ~/.ssh 目录和 ~/.ssh/authorized_keys 文件：</p><blockquote><p>chown -R deploy:deploy ~/.ssh<br>chmod 700 ~/.ssh<br>chmod 600 ~/.ssh/authorized_keys</p></blockquote><p>至此，所有工作完成，你可以在本地通过 SSH 密钥对认证登录到这条远程服务器了。</p><h4 id="禁用密码，禁止根用户登录"><a href="#禁用密码，禁止根用户登录" class="headerlink" title="禁用密码，禁止根用户登录"></a>禁用密码，禁止根用户登录</h4><p>下面我们要禁止所有用户通过密码登录，还要禁止根用户登录。</p><p>登录到远程服务器后，打开 SSH 配置文件 /etc/ssh/sshd_config，找到 PasswordAuthentication 设置，将其改为 no；然后，找到 PermitRootLogin 设置，将其改为 no，之后保存改动，执行下面的命令重启 SSH 服务，让改动生效：</p><blockquote><p># Ubuntu<br>sudo service ssh restart</p><p># CentOS<br>sudo systemctl restart sshd.service</p></blockquote><p>服务器的安全是长久任务，需要长期关注，除了以上配置外，还建议安装防火墙。Ubuntu 用户可以使用 UFW，CentOS 用户可以使用 firewalld 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主机&quot;&gt;&lt;a href=&quot;#主机&quot; class=&quot;headerlink&quot; title=&quot;主机&quot;&gt;&lt;/a&gt;主机&lt;/h3&gt;&lt;p&gt;PHP 应用开发好了之后，还需要部署到远程主机上，才能让用户访问我们提供的服务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>php编译参数configure配置详解</title>
    <link href="http://yoursite.com/2018/07/18/php%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0configure%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/07/18/php编译参数configure配置详解/</id>
    <published>2018-07-18T20:15:14.000Z</published>
    <updated>2019-04-12T09:23:21.267Z</updated>
    
    <content type="html"><![CDATA[<p>编译参数-使用<br>./configure -h<br>在源代码目录中，该命令可以查看所有编译参数以及对应的英文解释<br><a id="more"></a><br>编译参数-说明</p><blockquote><p>–prefix=/opt/php //指定 php 安装目录<br>–with-apxs2=/usr/local/apache/bin/apxs //整合Apache<br>–with-config-file-path=/opt/php/etc //指定php.ini位置<br>–with-config-file-scan-dir=/opt/php/etc/php.d //指定额外拓展配置归放处文件夹<br>–enable-safe-mode //打开安全模式<br>–enable-ftp //打开ftp的支持<br>–enable-zip //打开对zip的支持<br>–with-bz2 //打开对bz2文件的支持<br>–with-jpeg-dir //打开对jpeg图片的支持<br>–with-png-dir //打开对png图片的支持<br>–with-freetype-dir //打开对freetype字体库的支持<br>–without-iconv //关闭iconv函数，各种字符集间的转换<br>–with-libXML-dir //打开libxml2库的支持<br>–with-XMLrpc //打开xml-rpc的c语言<br>–with-zlib-dir //打开zlib库的支持<br>–with-gd //打开gd库的支持<br>–enable-gd-native-ttf //支持TrueType字符串函数库<br>–with-curl //打开curl浏览工具的支持<br>–with-curlwrappers //运用curl工具打开url流<br>–with-ttf //打开freetype1.*的支持，可以不加了<br>–with-xsl //打开XSLT 文件支持，扩展了libXML2库 ，需要libxslt软件<br>–with-gettext //打开gnu 的gettext 支持，编码库用到<br>–with-pear //打开pear命令的支持，PHP扩展用的<br>–enable-calendar //打开日历扩展功能<br>–enable-mbstring //多字节，字符串的支持<br>–enable-bcmath //精度计算，解决蛋疼的数字运算精度问题<br>–enable-sockets //打开 sockets 支持<br>–enable-exif //图片的元数据支持<br>–enable-magic-quotes //魔术引用的支持<br>–disable-rpath //关闭额外的运行库文件<br>–disable-debug //关闭调试模式<br>–with-ldap-dir //轻量目录访问协议 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编译参数-使用&lt;br&gt;./configure -h&lt;br&gt;在源代码目录中，该命令可以查看所有编译参数以及对应的英文解释&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简介</title>
    <link href="http://yoursite.com/2018/07/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1/"/>
    <id>http://yoursite.com/2018/07/18/设计模式-1/</id>
    <published>2018-07-18T19:24:38.000Z</published>
    <updated>2019-04-12T09:23:27.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>保证一个类仅有一个实例，并提供一个访问他的全局访问点例如框架中的数据库连接 - 类似DB类</p></blockquote><a id="more"></a><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote><p>针对一组算法，将每一个算法封装到具有共同接口的独立的类中，例如进入个人主页时，根据浏览者的不同，给予不同的显示与操作 - 类似不同用户呈现不同效果</p></blockquote><h3 id="注册模式"><a href="#注册模式" class="headerlink" title="注册模式"></a>注册模式</h3><blockquote><p>提供了在程序中有条理的存放并管理一组全局对象 (object) - 类似服务提供者的注入</p></blockquote><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><blockquote><p>将不同接口适配成统一的API接口，例如数据操作有mysql、mysqli、pdo等，可利用适配器模式统一接口</p></blockquote><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote><p>一个对象通过添加一个方法使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。例如实现实现消息推送 - 将所有类的实例化注册到一个数组，通过循环批量执行类</p></blockquote><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><blockquote><p>不修改原类代码和继承的情况下动态扩展类的功能，例如框架的每个Controller文件会提供before和after方法 - 在某个方法或输出之前执行或之后执行，用于修饰</p></blockquote><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><blockquote><p>提供一个方法顺序访问一个聚合对象中各个元素，在PHP中将继承 Iterator 类 - yield</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;保证一个类仅有一个实例，并提供一个访问他的全局访问点例如框架中的数据库连接 - 类似DB类&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP性能分析及追踪工具（XHPROF）</title>
    <link href="http://yoursite.com/2018/07/16/php%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/16/php性能分析/</id>
    <published>2018-07-17T03:07:28.000Z</published>
    <updated>2019-04-12T09:23:20.626Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是XHPROF？"><a href="#什么是XHPROF？" class="headerlink" title="什么是XHPROF？"></a>什么是XHPROF？</h3><p>XHPROF：Facebook 开源的轻量级PHP性能分析工具。</p><p>它报告函数级别的请求次数和各种指标，包括阻塞时间，CPU时间和内存使用情况。<br><a id="more"></a><br>XHProf分析报告有助于理解被执行的代码的结构，它有一个简单的HTML的用户界面（ PHP写成的）。</p><p>基于浏览器的性能分析用户界面能更容易查看，或是与同行们分享成果。</p><p>也能绘制调用关系图。</p><h3 id="XHPROF-与-Xdebug-区别"><a href="#XHPROF-与-Xdebug-区别" class="headerlink" title="XHPROF 与 Xdebug 区别"></a>XHPROF 与 Xdebug 区别</h3><p>Xdebug 是一个开放源代码的PHP程序调试器(即一个Debug工具)。</p><p>对于本地开发环境来说，进行性能分析 Xdebug 是够用了。</p><p>但如果是线上环境的话，Xdebug 消耗较大，配置也不够灵活。</p><h3 id="如何安装-XHPROF-？"><a href="#如何安装-XHPROF-？" class="headerlink" title="如何安装 XHPROF ？"></a>如何安装 XHPROF ？</h3><blockquote><p>//源码安装<br> cd /usr/local/src<br> //php5.6版本<br> git clone <a href="https://github.com/phacility/xhprof.git" target="_blank" rel="noopener">https://github.com/phacility/xhprof.git</a><br> //php7以上版本<br> git clone <a href="https://github.com/longxinH/xhprof.git" target="_blank" rel="noopener">https://github.com/longxinH/xhprof.git</a><br> //进入目录进行扩展编译<br> cd xhprof/extension<br> /usr/local/php/bin/phpize<br> ./configure –with-php-config=/usr/local/php/bin/php-config<br> make<br> make install<br> //在 php.ini 末尾新增<br> [xhprof]<br> extension = xhprof.so<br> xhprof.output_dir = 自定义文件夹(/tmp/xhprof_log)<br> // /tmp/xhprof_log 必须存在且有写入权限<br> //重启环境<br> //代码中查看 phpinfo 是否包含 xhprof。<br> //一切顺利的话，那么 xhprof 安装成功。  </p></blockquote><h3 id="如何配置-XHPROF？"><a href="#如何配置-XHPROF？" class="headerlink" title="如何配置 XHPROF？"></a>如何配置 XHPROF？</h3><blockquote><p>//比如项目地址：local.test_xhprof.com<br> //在项目入口文件中新增一下代码（CI框架为例）<br> xhprof_enable(XHPROF_FLAGS_NO_BUILTINS +<br>               XHPROF_FLAGS_CPU +<br>               XHPROF_FLAGS_MEMORY);<br> register_shutdown_function(function(){<br>     $data = xhprof_disable();   //返回运行数据<br>     //xhprof_lib 在下载的包里存在这个目录,记得将目录包含到运行的php代码中<br>     include ‘/home/www/mi/xhprof/xhprof_lib/utils/xhprof_lib.php’;<br>     include ‘/home/www/mi/xhprof/xhprof_lib/utils/xhprof_runs.php’;<br>     $objXhprofRun = new XHProfRuns_Default();<br>     $objXhprofRun-&gt;save_run($data, “test”); //test 表示文件后缀<br> });<br> //一切顺利的话，那么代码安装成功。<br> //访问：local.test_xhprof.com，应该在 /tmp/xhprof_log 存在日志文件。  </p></blockquote><h3 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h3><p>可以直接运行从github上clone下来的文件里面example目录下的那个例子</p><p>输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [main()] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [ct] =&gt; 1</span><br><span class="line">            [wt] =&gt; 9</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">---------------</span><br><span class="line">Assuming you have set up the http based UI for </span><br><span class="line">XHProf at some address, you can view run at </span><br><span class="line">http://&lt;xhprof-ui-address&gt;/index.php?run=592567308784c&amp;source=xhprof_foo</span><br><span class="line">---------------</span><br></pre></td></tr></table></figure></p><p>然后复制index.php后面的?run=592567308784c&amp;source=xhprof_foo</p><p>访问</p><blockquote><p>xhprof_html/index.php?run=592567308784c&amp;source=xhprof_foo</p></blockquote><p>可看见输出</p><p><img src="http://oxp5uo96p.bkt.clouddn.com/hexo/xhprof/1.png" alt="p1"></p><p>点击中间的 View Full Callgraph 即可看见性能分析图片</p><p>在生成图的时候需要服务器装一个插件：graphviz。</p><blockquote><p>cd /usr/local/src<br> wget <a href="http://www.graphviz.org/pub/graphviz/stable/SOURCES/graphviz-2.24.0.tar.gz" target="_blank" rel="noopener">http://www.graphviz.org/pub/graphviz/stable/SOURCES/graphviz-2.24.0.tar.gz</a><br> tar zxvf graphviz-2.24.0.tar.gz<br> cd graphviz-2.24.0<br> ./configure<br> make<br> make install<br> 如果点击 [View Full Callgraph] 依旧无法打开。<br> 报错：failed to execute cmd “ dot -Tpng”<br> 表示：php.ini 中一些执行函数禁用了。<br> 在 php.ini 中 去掉 disable_functions 中的如下函数<br> system<br> shell_exec<br> proc_open<br> proc_get_status<br> PHP 重启一下。<br> 一切顺利的话，应该不会报错了，就可以看到高大上的效果图啦。  </p></blockquote><p>如果想测试自己的项目，例如一款框架的性能分析。</p><p>复制xhprof_lib/utils/下的两个文件</p><p>xhprof_lib.php和xhprof_runs.php到入口文件同级目录，然后在入口文件起始位置添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// start profiling</span><br><span class="line">xhprof_enable();</span><br></pre></td></tr></table></figure><p>结束位置添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// stop profiler</span><br><span class="line">$xhprof_data = xhprof_disable();</span><br><span class="line"></span><br><span class="line">// display raw xhprof data for the profiler run</span><br><span class="line">print_r($xhprof_data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include_once &quot;xhprof_lib.php&quot;;</span><br><span class="line">include_once &quot;xhprof_runs.php&quot;;</span><br><span class="line"></span><br><span class="line">// save raw data for this profiler run using default</span><br><span class="line">// implementation of iXHProfRuns.</span><br><span class="line">$xhprof_runs = new XHProfRuns_Default();</span><br><span class="line"></span><br><span class="line">// save the run under a namespace &quot;xhprof_foo&quot;</span><br><span class="line">$run_id = $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_foo&quot;);</span><br><span class="line"></span><br><span class="line">echo &quot;---------------\n&quot;.</span><br><span class="line">     &quot;Assuming you have set up the http based UI for \n&quot;.</span><br><span class="line">     &quot;XHProf at some address, you can view run at \n&quot;.</span><br><span class="line">     &quot;http://&lt;xhprof-ui-address&gt;/index.php?run=$run_id&amp;source=xhprof_foo\n&quot;.</span><br><span class="line">     &quot;---------------\n&quot;;</span><br></pre></td></tr></table></figure></p><p>即可得到如上所示的那个url，然后再次去访问</p><p>http://<strong><em>/xhprof_html/index.php?run=**</em></strong>&amp;source=xhprof_foo </p><p>得到如下所示页面</p><p><img src="http://oxp5uo96p.bkt.clouddn.com/hexo/xhprof/2.png" alt="p2"></p><p>点击”View Full Callgraph”显示下图。</p><p><img src="http://oxp5uo96p.bkt.clouddn.com/hexo/xhprof/3.png" alt="p3"></p><h3 id="如何-UI-展示？"><a href="#如何-UI-展示？" class="headerlink" title="如何 UI 展示？"></a>如何 UI 展示？</h3><p>可能大家有一些疑问：</p><blockquote><p>是否能有更好的UI展示？<br>当服务器上有多个站点的时候，是否配置一次即可？  </p></blockquote><p>接下来给大家介绍：xhprof gui</p><p>xhprof gui : 一个xhprof的一个ui展现。</p><p>使 xhprof 界面更漂亮，功能更强大。</p><blockquote><p>友好的界面<br>数据库存储（mysql）<br>支持按请求百分比执行 xhprof 优化。<br>降低服务器负载。</p></blockquote><h3 id="如何配置-xhprof-gui"><a href="#如何配置-xhprof-gui" class="headerlink" title="如何配置 xhprof gui"></a>如何配置 xhprof gui</h3><p>源码地址：<a href="https://github.com/preinheimer/xhprof" target="_blank" rel="noopener">https://github.com/preinheimer/xhprof</a></p><p>下载后存放到：xhprof_gui 文件中。</p><p>配置虚拟主机(local.xhprofgui.com)</p><p>local.xhprofgui.com 指向 /home/www/mi/xhprof_gui/ 即可。</p><p>第一步，需要将 xhprof_gui/xhprof_lib/config.sample.php 重命名 为 config.php。</p><p>第二步，根据 config.php 中数据库变量(dbuser、dbpass、dbname)，配置一个数据库。</p><p>第三步，将 config.php 中 doprofile 设置为 true。</p><p>第四步，创建一张表。</p><blockquote><p>//源代码：xhprof_lib/utils/xhprof_runs.php<br> CREATE TABLE <code>details</code> (<br>   <code>id</code> char(17) NOT NULL,<br>   <code>url</code> varchar(255) default NULL,<br>   <code>c_url</code> varchar(255) default NULL,<br>   <code>timestamp</code> timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP,<br>   <code>server name</code> varchar(64) default NULL,<br>   <code>perfdata</code> MEDIUMBLOB,<br>   <code>type</code> tinyint(4) default NULL,<br>   <code>cookie</code> BLOB,<br>   <code>post</code> BLOB,<br>   <code>get</code> BLOB,<br>   <code>pmu</code> int(11) unsigned default NULL,<br>   <code>wt</code> int(11) unsigned default NULL,<br>   <code>cpu</code> int(11) unsigned default NULL,<br>   <code>server_id</code> char(3) NOT NULL default ‘t11’,<br>   <code>aggregateCalls_include</code> varchar(255) DEFAULT NULL,<br>   PRIMARY KEY  (<code>id</code>),<br>   KEY <code>url</code> (<code>url</code>),<br>   KEY <code>c_url</code> (<code>c_url</code>),<br>   KEY <code>cpu</code> (<code>cpu</code>),<br>   KEY <code>wt</code> (<code>wt</code>),<br>   KEY <code>pmu</code> (<code>pmu</code>),<br>   KEY <code>timestamp</code> (<code>timestamp</code>)<br> ) ENGINE=MyISAM DEFAULT CHARSET=utf8;  </p></blockquote><p> 如果是 Nginx 服务器 新增配置：</p><blockquote><p>fastcgi_param PHP_VALUE “auto_prepend_file=/home/www/mi/xhprof_gui/external/header.php”;</p></blockquote><p>如果是 Apache 服务器：</p><blockquote><p>php_admin_value auto_prepend_file “/home/www/mi/xhprof_gui/external/header.php”</p></blockquote><p>配置到这里，可以运行下。</p><p>简单说明下：</p><p>如果你配置在公共的配置文件中，那么表示站点上所有的域名访问都会进行日志记录。</p><p>如果你配置在单个域名的配置文件中，表示只有访问当前域名的时候回进入日志记录。</p><p>例如单个域名为：local.xh.test.com</p><p>如果报错，可以调试下 header.php。</p><p>以上配置，存储使用的是Mysql。</p><p>存储也可以使用MongoDB，大家可以研究下 ~</p><p>如果看到效果？</p><p>访问 local.xh.test.com，记录日志。</p><p>访问 local.xhprofgui.com，查看效果。</p><p>效果图，如下：</p><p><img src="http://oxp5uo96p.bkt.clouddn.com/hexo/xhprof/4.gif" alt="p4"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是XHPROF？&quot;&gt;&lt;a href=&quot;#什么是XHPROF？&quot; class=&quot;headerlink&quot; title=&quot;什么是XHPROF？&quot;&gt;&lt;/a&gt;什么是XHPROF？&lt;/h3&gt;&lt;p&gt;XHPROF：Facebook 开源的轻量级PHP性能分析工具。&lt;/p&gt;
&lt;p&gt;它报告函数级别的请求次数和各种指标，包括阻塞时间，CPU时间和内存使用情况。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>php实现经典算法-2</title>
    <link href="http://yoursite.com/2018/07/16/algorithm-2/"/>
    <id>http://yoursite.com/2018/07/16/algorithm-2/</id>
    <published>2018-07-16T16:22:33.000Z</published>
    <updated>2019-04-12T09:23:14.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function fib($n) &#123;</span><br><span class="line">    if($n &lt;= 0) return 0;</span><br><span class="line">    if ($n &lt;= 2) return 1;</span><br><span class="line">    return fib($n - 1) + fib($n - 2);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">function fib2($n) &#123;</span><br><span class="line">    if ($n &lt;= 2) return 1;</span><br><span class="line">    $arr = [0,1,1];</span><br><span class="line">    for ($i = 3; $i &lt;= $n; $i++) &#123;</span><br><span class="line">        $arr[$i] = $arr[$i - 1] + $arr[$i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr[$n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>初识elastcisearch</title>
    <link href="http://yoursite.com/2018/07/16/elasticsearch-1/"/>
    <id>http://yoursite.com/2018/07/16/elasticsearch-1/</id>
    <published>2018-07-16T13:23:47.000Z</published>
    <updated>2019-04-15T02:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-从安装elasticsearch开始"><a href="#1-从安装elasticsearch开始" class="headerlink" title="1.从安装elasticsearch开始"></a>1.从安装elasticsearch开始</h3><p>从<a href="https://www.elastic.co/downloads/past-releases" target="_blank" rel="noopener">elasticsearch官网</a>下载软件包，因为公司数据仓库用的是5.3版本，所以我下载了elasticasearch-5.3。<br><a id="more"></a><br>当你解压好了归档文件之后，Elasticsearch 已经准备好运行了。按照下面的操作，在前台(foregroud)启动 Elasticsearch：</p><blockquote><p>su elasticserach (切换到非root用户，我新建了用户elasticsearch)<br>cd elasticsearch-5.3.0<br>./bin/elasticsearch (注意不能以root用户运行) </p></blockquote><p>如图启动服务成功时的样子:</p><p><img src="/2018/07/16/elasticsearch-1/2.jpg" alt="p2"></p><p>测试 Elasticsearch 是否启动成功，可以打开另一个终端，执行以下操作：</p><blockquote><p>curl ‘<a href="http://localhost:9200/?pretty&#39;" target="_blank" rel="noopener">http://localhost:9200/?pretty&#39;</a></p></blockquote><p>你应该得到和下面类似的响应(response)：</p><p><img src="/2018/07/16/elasticsearch-1/3.jpg" alt="p3"></p><p>这就意味着你现在已经启动并运行一个 Elasticsearch 节点了，你可以用它做实验了。 单个 节点 可以作为一个运行中的 Elasticsearch 的实例。</p><h3 id="2-安装插件elasticsearch-head（类似navicat之于mysql）"><a href="#2-安装插件elasticsearch-head（类似navicat之于mysql）" class="headerlink" title="2.安装插件elasticsearch-head（类似navicat之于mysql）"></a>2.安装插件elasticsearch-head（类似navicat之于mysql）</h3><p>搭建elasticsearch-head服务（之前需安装nodejs）</p><blockquote><p>git clone git://github.com/mobz/elasticsearch-head.git<br>cd elasticsearch-head<br>npm install<br>npm run start<br>open <a href="http://localhost:9100/" target="_blank" rel="noopener">http://localhost:9100/</a>  </p></blockquote><p>浏览器查看数据如图:</p><p><img src="/2018/07/16/elasticsearch-1/1.jpg" alt="p1"></p><h3 id="3-也许你还需要同步mysql至elasticsearch"><a href="#3-也许你还需要同步mysql至elasticsearch" class="headerlink" title="3.也许你还需要同步mysql至elasticsearch"></a>3.也许你还需要同步mysql至elasticsearch</h3><p>搭建go-mysql-elasticsearch服务</p><blockquote><p>安装 Go (1.6+) 然后设置 GO的环境变量<br>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:siddontang/go-mysql-elasticsearch.git<br>cd $GOPATH/src/github.com/siddontang/go-mysql-elasticsearch<br>make</p></blockquote><p>在目录$GOPATH/src/github.com/siddontang/go-mysql-elasticsearch/etc/之下建立toml文件，用做同步配置</p><p>具体参见<a href="https://github.com/siddontang/go-mysql-elasticsearch" target="_blank" rel="noopener">go-mysql-elasticsearch官网</a></p><p>以上搭建elasticsearch引擎、数据同步工具和查看工具完成</p><h3 id="4-php安装elasticsearch扩展"><a href="#4-php安装elasticsearch扩展" class="headerlink" title="4.php安装elasticsearch扩展"></a>4.php安装elasticsearch扩展</h3><p>使用composer安装扩展，在composer.json中写入</p><blockquote><p>{<br>     “require”: {<br>         “elasticsearch/elasticsearch”: “~5.0”<br>     }<br> }</p></blockquote><p>因为我安装的是5.3.0，故使用”~5.0”，如果安装的6.0以上，需使用”~6.0”。</p><h3 id="5-创建elasticsearch索引（类似mysql的数据库）"><a href="#5-创建elasticsearch索引（类似mysql的数据库）" class="headerlink" title="5.创建elasticsearch索引（类似mysql的数据库）"></a>5.创建elasticsearch索引（类似mysql的数据库）</h3><p>我使用代码的方式创建索引，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">class EsClient</span><br><span class="line">&#123;</span><br><span class="line">    private $client;</span><br><span class="line">    //初始化连接elasticsearch</span><br><span class="line">    public function __construct()&#123;</span><br><span class="line">        $this-&gt;client = ClientBuilder::create()-&gt;setHosts([&apos;127.0.0.1:9200&apos;])-&gt;build(); //这边填ip地址</span><br><span class="line">    &#125;</span><br><span class="line">    //查询索引内容</span><br><span class="line">    public function getSource($scheme,$body)&#123;</span><br><span class="line">        $params = [</span><br><span class="line">            &apos;index&apos; =&gt;  $scheme,   //[&apos;log_osdk_payment_stat_daily&apos;, &apos;my_index2&apos;],可以通过这种形式进行跨库查询</span><br><span class="line">            &apos;type&apos; =&gt; $scheme,//[&apos;my_type1&apos;, &apos;my_type2&apos;],</span><br><span class="line">            &apos;body&apos; =&gt; $body</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        $res = $this-&gt;client-&gt;search($params);</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    //创建设备信息表的索引</span><br><span class="line">    public function createDeviceInfoIndex()</span><br><span class="line">    &#123;</span><br><span class="line">        $index = [&apos;log_osdk_device_info_196377445_201804&apos;];</span><br><span class="line">        foreach ($index as $v)&#123;</span><br><span class="line">            $params = [</span><br><span class="line">                &apos;index&apos; =&gt; $v,</span><br><span class="line">                &apos;body&apos; =&gt; [</span><br><span class="line">                    &apos;settings&apos; =&gt; [</span><br><span class="line">                        &apos;number_of_shards&apos; =&gt; 5,</span><br><span class="line">                        &apos;number_of_replicas&apos; =&gt; 1</span><br><span class="line">                    ],</span><br><span class="line">                    &apos;mappings&apos; =&gt; [</span><br><span class="line">                        $v =&gt; [</span><br><span class="line">                            &apos;_source&apos; =&gt; [</span><br><span class="line">                                &apos;enabled&apos; =&gt; true</span><br><span class="line">                            ],</span><br><span class="line">                            &apos;properties&apos; =&gt; [</span><br><span class="line">                                &apos;osdk_game_id&apos; =&gt; [</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;text&apos;,</span><br><span class="line">                                    &apos;fielddata&apos; =&gt; true //text如果fielddata为false，将不支持聚合操作</span><br><span class="line">                                ],</span><br><span class="line">                                &apos;deivce_id&apos; =&gt; [</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;text&apos;,</span><br><span class="line">                                    &apos;fielddata&apos; =&gt; true</span><br><span class="line">                                ],</span><br><span class="line">                                &apos;factory&apos; =&gt; [</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;keyword&apos;,</span><br><span class="line">                                ],</span><br><span class="line">                                &apos;model&apos; =&gt; [</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;keyword&apos;,</span><br><span class="line">                                ],</span><br><span class="line">                                &apos;os&apos; =&gt; [</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;keyword&apos;,</span><br><span class="line">                                ],</span><br><span class="line">                                &apos;total_mem&apos; =&gt; [</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;keyword&apos;,</span><br><span class="line">                                ],</span><br><span class="line">                                &apos;mem_standard&apos; =&gt;[</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;keyword&apos;,</span><br><span class="line">                                ],</span><br><span class="line">                                &apos;total_disk&apos; =&gt; [</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;keyword&apos;,</span><br><span class="line">                                ],</span><br><span class="line">                                &apos;disk_standard&apos; =&gt;[</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;keyword&apos;,</span><br><span class="line">                                ],</span><br><span class="line">                                &apos;resolution&apos; =&gt;[</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;keyword&apos;,</span><br><span class="line">                                ],</span><br><span class="line"></span><br><span class="line">                                &apos;tt&apos; =&gt; [</span><br><span class="line">                                    &apos;type&apos; =&gt; &apos;text&apos;,</span><br><span class="line">                                    &apos;fielddata&apos; =&gt; true</span><br><span class="line">                                ],</span><br><span class="line">                            ]</span><br><span class="line">                        ]</span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            ];</span><br><span class="line">            $response = $this-&gt;client-&gt;indices()-&gt;create($params);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用DSL语句进行查询，php-elasticsearch将其封装成了数组"><a href="#使用DSL语句进行查询，php-elasticsearch将其封装成了数组" class="headerlink" title="使用DSL语句进行查询，php-elasticsearch将其封装成了数组"></a>使用DSL语句进行查询，php-elasticsearch将其封装成了数组</h3><p>直接放代码了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">use modules\Data\components\EsClient;</span><br><span class="line">class LogDeviceInfoService</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * SELECT COUNT(*) as num,model from log_osdk_device_info_196377445_201804 where tt BETWEEN 20180401 AND 20180430 GROUP BY model ORDER BY num DESC limit 5</span><br><span class="line">     * @param $game_id</span><br><span class="line">     * @param $field</span><br><span class="line">     * @param $begin_date</span><br><span class="line">     * @param $end_date</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function getCountGroupByFieldFromDeviceInfo($game_id, $field, $begin_date, $end_date)</span><br><span class="line">    &#123;</span><br><span class="line">        $scheme = &apos;log_osdk_device_info_196377445_201804&apos;;</span><br><span class="line">        $body =</span><br><span class="line">            [</span><br><span class="line">                &apos;query&apos; =&gt; [</span><br><span class="line">                    &apos;bool&apos; =&gt; [</span><br><span class="line">                        &apos;filter&apos; =&gt; [</span><br><span class="line">                            &quot;range&quot; =&gt; [</span><br><span class="line">                                &quot;tt&quot; =&gt; [</span><br><span class="line">                                    &quot;gte&quot; =&gt; $begin_date, &quot;lte&quot; =&gt; $end_date</span><br><span class="line">                                ]</span><br><span class="line">                            ],</span><br><span class="line">                        ],</span><br><span class="line">                       &quot;must&quot; =&gt; [</span><br><span class="line">                            [&quot;term&quot; =&gt; [&quot;osdk_game_id&quot; =&gt; $game_id]],</span><br><span class="line">                        ],</span><br><span class="line">                        &quot;must_not&quot; =&gt; [</span><br><span class="line">                            [&quot;term&quot; =&gt; [$field =&gt; &apos;&apos;]],</span><br><span class="line">                        ]</span><br><span class="line">                    ],</span><br><span class="line">                ],</span><br><span class="line">                &quot;aggs&quot; =&gt; [</span><br><span class="line">                    &quot;group_by&quot;=&gt;[</span><br><span class="line">                        &quot;terms&quot;=&gt;[</span><br><span class="line">                            &quot;field&quot;=&gt;$field,</span><br><span class="line">                            &quot;size&quot;=&gt; 5,</span><br><span class="line">                        ],</span><br><span class="line">                    ],</span><br><span class="line">                ],</span><br><span class="line">            ];</span><br><span class="line">        $es_client = new EsClient();</span><br><span class="line">        $result = $es_client-&gt;getSource($scheme, $body)[&apos;aggregations&apos;][&apos;group_by&apos;][&apos;buckets&apos;];</span><br><span class="line">        return $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SELECT COUNT(*) from log_osdk_device_info_196377445_201804 where tt BETWEEN 20180401 AND 20180430</span><br><span class="line">     * @param $game_id</span><br><span class="line">     * @param $begin_date</span><br><span class="line">     * @param $end_date</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function getCountFromDeviceInfo($game_id, $begin_date, $end_date)</span><br><span class="line">    &#123;</span><br><span class="line">        $scheme = &apos;log_osdk_device_info_196377445_201804&apos;;</span><br><span class="line">        $body =</span><br><span class="line">            [</span><br><span class="line">                &apos;query&apos; =&gt; [</span><br><span class="line">                    &apos;bool&apos; =&gt; [</span><br><span class="line">                        &apos;filter&apos; =&gt; [</span><br><span class="line">                            &quot;range&quot; =&gt; [</span><br><span class="line">                                &quot;tt&quot; =&gt; [</span><br><span class="line">                                    &quot;gte&quot; =&gt; $begin_date, &quot;lte&quot; =&gt; $end_date</span><br><span class="line">                                ]</span><br><span class="line">                            ],</span><br><span class="line">                        ],</span><br><span class="line">                       &quot;must&quot; =&gt; [</span><br><span class="line">                            [&quot;term&quot; =&gt; [&quot;osdk_game_id&quot; =&gt; $game_id]],</span><br><span class="line">                        ],</span><br><span class="line">                    ],</span><br><span class="line">                ],</span><br><span class="line">            ];</span><br><span class="line">        $es_client = new EsClient();</span><br><span class="line">        $result = $es_client-&gt;getSource($scheme, $body)[&apos;hits&apos;][&apos;total&apos;];</span><br><span class="line">        return $result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getCountGroupByFieldFromDeviceInfo的返回是这样的:</p><p><img src="/2018/07/16/elasticsearch-1/4.jpg" alt="p4"></p><p>今天就写这些了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-从安装elasticsearch开始&quot;&gt;&lt;a href=&quot;#1-从安装elasticsearch开始&quot; class=&quot;headerlink&quot; title=&quot;1.从安装elasticsearch开始&quot;&gt;&lt;/a&gt;1.从安装elasticsearch开始&lt;/h3&gt;&lt;p&gt;从&lt;a href=&quot;https://www.elastic.co/downloads/past-releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;elasticsearch官网&lt;/a&gt;下载软件包，因为公司数据仓库用的是5.3版本，所以我下载了elasticasearch-5.3。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES" scheme="http://yoursite.com/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>RPC原理及PHP的RPC框架</title>
    <link href="http://yoursite.com/2018/07/10/RPC%E5%8E%9F%E7%90%86%E5%8F%8APHP%E7%9A%84RPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/07/10/RPC原理及PHP的RPC框架/</id>
    <published>2018-07-10T14:56:30.000Z</published>
    <updated>2019-04-12T09:23:22.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPC-远程过程调用协议"><a href="#RPC-远程过程调用协议" class="headerlink" title="RPC(远程过程调用协议)"></a>RPC(远程过程调用协议)</h2><blockquote><p>RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<br>RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。<a id="more"></a><br>RPC使得开发包括网络分布式多程序在内的应用程序更加容易。<br>RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。<br>首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。<br>在服务器端，进程保持睡眠状态直到调用信息到达为止。<br>当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p></blockquote><h2 id="远程调用原理"><a href="#远程调用原理" class="headerlink" title="远程调用原理"></a>远程调用原理</h2><p>比如 A (client) 调用 B (server) 提供的<strong>remoteAdd</strong>方法：<br>1.首先A与B之间建立一个TCP连接；<br>2.然后A把需要调用的方法名（这里是remoteAdd）以及方法参数（10， 20）序列化成字节流发送出去；<br>3.B接受A发送过来的字节流，然后反序列化得到目标方法名，方法参数，接着执行相应的方法调用（可能是localAdd）并把结果30返回；<br>4.A接受远程调用结果,输出30。</p><h2 id="远程调用的好处"><a href="#远程调用的好处" class="headerlink" title="远程调用的好处"></a>远程调用的好处</h2><p><strong>解耦</strong>：当server需要对方法内实现修改时，client完全感知不到，不用做任何变更；这种方式在跨部门，跨公司合作的时候经常用到，并且方法的提供者我们通常称为：服务的暴露。</p><h2 id="RPC与Socket有什么区别"><a href="#RPC与Socket有什么区别" class="headerlink" title="RPC与Socket有什么区别"></a>RPC与Socket有什么区别</h2><p>RPC（远程过程调用）采用客户机/服务器模式实现两个进程之间相互通信。socket是RPC经常采用的通信手段之一，RPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。除了Socket，RPC还有其他的通信方法，比如：http、操作系统自带的管道等技术来实现对于远程程序的调用。微软的Windows系统中，RPC就是采用命名管道进行通信。</p><h2 id="RPC与REST有什么区别"><a href="#RPC与REST有什么区别" class="headerlink" title="RPC与REST有什么区别"></a>RPC与REST有什么区别</h2><p><strong>REST API</strong>和<strong>RPC</strong>都是在<strong>Server端</strong> 把一个个函数封装成接口暴露出去，以供<strong>Client端</strong>调用，不过<strong>REST API</strong>是基于HTTP协议的，<strong>REST</strong>致力于通过HTTP协议中的POST/GET/PUT/DELETE等方法和一个可读性强的URL来提供一个HTTP请求。<br>而<strong>RPC</strong>则可以不基于HTTP协议。因此，如果是后端两种语言互相调用，用<strong>RPC</strong>可以获得更好的性能（省去了HTTP报头等一系列东西），应该也更容易配置。如果是前端通过AJAX调用后端，那么用<strong>REST API</strong>的形式比较好（因为无论如何也避不开HTTP这道坎）。</p><h2 id="php中流行的rpc框架有哪些"><a href="#php中流行的rpc框架有哪些" class="headerlink" title="php中流行的rpc框架有哪些"></a>php中流行的rpc框架有哪些</h2><p>1.phprpc<br>2.yar<br>3.thrift<br>4.gRPC<br>5.swoole<br>6.hprose<br>嗯，具体运用去官网查文档</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RPC-远程过程调用协议&quot;&gt;&lt;a href=&quot;#RPC-远程过程调用协议&quot; class=&quot;headerlink&quot; title=&quot;RPC(远程过程调用协议)&quot;&gt;&lt;/a&gt;RPC(远程过程调用协议)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。&lt;br&gt;RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
  </entry>
  
</feed>
